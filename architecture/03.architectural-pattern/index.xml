<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>03.架构模式 on</title><link>https://doks.netlify.app/architecture/03.architectural-pattern/</link><description>Recent content in 03.架构模式 on</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Sat, 22 Apr 2023 12:52:56 +0800</lastBuildDate><atom:link href="https://doks.netlify.app/architecture/03.architectural-pattern/index.xml" rel="self" type="application/rss+xml"/><item><title>01 概述</title><link>https://doks.netlify.app/architecture/03.architectural-pattern/01-%E4%BB%8B%E7%BB%8D/</link><pubDate>Sat, 22 Apr 2023 12:52:56 +0800</pubDate><guid>https://doks.netlify.app/architecture/03.architectural-pattern/01-%E4%BB%8B%E7%BB%8D/</guid><description>背景： # 1. 学习背景 多年前在学习架构设计的过程中，无意间找到了叫做《架构模式》的架构设计方法论。从哪之后就开始逐渐的深入学习这方面的内容。在简书个人介绍中的：《规则对于智者来说是指导，对于愚者来说是遵从》。其实就是在学习《架构模式》是理解的真理。
在平常的工作过程中，有很多人会以经验的方式去知道具体的工作。遇到无经验可借鉴的时候就束手无策了。往往这些时候就是体现一个人学习能力的时候，所以，就需要一种借鉴其他人经验的方式。而架构模式就是前人为我们总结和模式化的架构设计实践中经验。
2. 内容范围 在软件界有很多种模式的概念，并在之后会推出系列的架构模式文章。所以需要大概的说明一下系列文章的内容范围，以区别其他知识领域并方便的指导学习过程。
在搜索引擎上搜索《架构模式》时，最可能搜到的是Martin Fowler的《企业应用架构模式》。这本书的主要介绍的范围是在软件开发中可能会遇到的各种知识点，以及GoF设计模式的具体落地方式等等。所以，这本书描述的内容基本上在《架构设计01&amp;ndash;架构师知识体系》底层的实现技术与设计模式部分。
本文中介绍的内容更多的是《软件体系结构》和《软件体系结构原理、方法与实践》中的内容。这两本书描述从软件架构的层面上通用模式。所以，可以理解为本系列文章的主要内容是介绍软件体系结构。
因为每个人经历、知识体系都是不一样的，并且写文章所要介绍的内容也不尽相同。所以在网上可以找到很多种的架构模式的理解。例如：《10 Common Software Architectural Patterns in a nutshell》，《朱晔的互联网架构实践心得S1E7：三十种架构设计模式（上）》，《《软件架构模式》-第一章分层架构（上）》。在这里介绍的内容与其他介绍的内容没有什么好坏之分，只不过在软件体系结构中介绍的内容的细分领域不同。所以，作为一个软件从业人员尽量的多去学习，多去理解才是最终要的。不用进行比较。
概述： # 1. 架构设计到底干了什么？ 架构的基本需求主要是在满足功能属性的前提下，关注软件质量属性，架构设计则是为了满足架构需求（软件质量）寻求适当的”战术“；
2. 软件架构设计的意义？
项目关系人之间的交流平台 在软件过程中，软件系统中会有各种各样的关系人进入。软件系统的多种关系人在不同的时候分别关注系统不同的特性。我们可以从软件架构的&amp;quot;4+1&amp;quot;视图模型中看不同人的需求。 早期设计决策 在精益中有个规则，叫做推迟决策。相应的敏捷中也需要支持尽快决策。在软件开发的开发初期可以实现MVP，对其进行各方面的评估与验证。因为在软件过程中不确定因素很多，刚开始很难预测未来的变化，一开始保留较大的弹性。软件需求分三种：功能需求，质量需求和设计约束。在开始进行架构设计时就可以考虑这三种需求来完成相应的决策。
在较高层面上体现软件的复用 软件质量中有一条软件可复用性，不要认为软件工程中的规则、原则、指导等都只能停留在它所固定的层次上。软件的可复用性并不只代表代码的复用性，它代表了软件开发层次中的各个层次。在组件化开发中软件可复用性可以体现在组件的服用。在架构设计层面的可复用性，就可以说架构模式了。
架构对开发的指导与规范意义不可忽视。 架构的指导意义体现在所有的人员都有一个共同的目标。在团队中一致的目标能让团队更高效的完成任务。并且可以形成软件中的统一语言，方便团队中的沟通。
说明： # 1. 以怎样的方式描述架构模式？ # 根据软件实施经验、并综合架构模式的定义进行对软件架构进行描述。也会说明具体的架构模式的适用范围，以及使用过程中的注意事项。
2. 软件架构的生命周期？ # 从演进式架构还没有出现时，总有一种模糊的感觉：架构不是一蹴而就的。在遗留系统怎样更新到新架构、现在正在运行的软件产品怎样持续的进行改进、新系统设计时怎样考虑它的可扩展行？这些都是对软件架构的要求。所以，一直在思考，但是《演进式架构》出现后才真正的理解。
3. 架构模式分类 # GoF为我们总结了23种设计模式。我们在这里说明10种架构模式。具体类型为：
分层架构模式 事件驱动架构模式 微内核架构模式 微服务架构模式 云架构模式 命令查询指责分离模式 仓库系统及知识库 控制环路模式 管道过滤器模式 无服务器架构 参考： # 设计恰如其分的架构 新书推荐 | 拥抱变化：演进式架构设计 技术实践如何支持演进式架构和持续集成 微服务即演进式架构 微服务和演进式架构</description></item><item><title>02 分层架构模式</title><link>https://doks.netlify.app/architecture/03.architectural-pattern/02-%E5%88%86%E5%B1%82%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/</link><pubDate>Sat, 22 Apr 2023 12:52:56 +0800</pubDate><guid>https://doks.netlify.app/architecture/03.architectural-pattern/02-%E5%88%86%E5%B1%82%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/</guid><description>介绍 # 分层架构是最常见，也是最容易理解的架构模式。因为在现实生活中会遇到很多类似的例子与模型。例如在在装修的时候或者为一个金属器物刷油漆时最常见的方式就是刷多层。第一层刷石膏，第二层刷腻子，第三层刷乳胶漆。而且每一层都有它自己的意义。刷墙的时候石膏是为了保证墙面平整的，刷腻子是为了防止开裂的，刷乳胶漆是为了美观的。所以，在软件上我们也有类似的结构，去帮助我们管理每个层面上不同的问题。
再比如在人资、心理学方面大名鼎鼎的马斯洛需求层次理论就是讲人类的需求分为几个层面。马斯洛理论以层次的方式体现人们对社会、对个人的需求或者理解。也有学者提出人们对这些需求层次中的需求是同时存在的。再更近一步，佛洛伊德把我又更加细化的分为自我，本我，超我。 从自我、本我、超我已经将分层模式进入到一种支配人们行动方式的层面了。所以，分层模式是生活、工作、学习中最常见也是做容易理解的模式。也从某方面说明分层模式并不一定非要是纵行分层，也不一定非要横向分层，可以事物跨层，或者洋葱层等等。
转回我们的软件行业。在《恰如其分的架构设计》中把架构设计中的模型也分了层次。分别是：领域模型，设计模型，代码模型。规定了从真实世界中的事物到技术实现层面的代码之间的关系。在下面具体介绍分层模式。
讲解 # 在OOA中我们经常会提到一个词：SOLID。这个词中第一个字母代表的意义就是单一职责。分层架构第一个目标是单一职责。在处理复杂问题的时候我们有几种办法：分解，知识，抽象。其实这些方法就是将一件事物去掉干扰，去掉非关键因素，提取和抽象出核心的过程。做这件事的意义在于每一个问题都有他自己要处理的核心问题，核心问题解决掉之后就能解决80%的问题。
第二个问题在于分层模式提供了高内聚低耦合的基础实现方法。分层架构第一步规定每层都是单一职责的。第二步就是规定每层不能深入到另外一层中。其实就是知识最少原则。这样让每层之间只能通过API（API是一个比较广泛的概念，可以是方法调用，可以是RPC，可以是事件）的方式去做交互。
分层架构为演进式架构提供了基础的支撑。分层可以提供内外部的隔离。也就是我们常说的微服务是以内部复杂度换为了外部复杂度。
在架构模式中一般不会简单的只是用某一种架构模式来搭建系统。而在架构模式中分层模式可谓是百搭。分层架构模式可以和任何架构模式组合搭配。
模式描述 # 首先，架构模式可以体现在不同的level上。就像上面提到的SOLID，最少知识原则最初都是体现在代码层面的设计上的。慢慢的会出现GoF的设计模式，以及本系列文章中介绍的架构模式。我们按照《恰如其分的架构设计》中对架构模型的分层，将架构分为：业务领域层，技术设计层，代码实现层。
架构模式可以在不同的层次上体现的方面，可以用分层模式举一个简单的例子。例如分层模式中的业务领域层可以中的分层模式可以是销售，制造，采购等。技术设计中可以是展示层，业务逻辑层，基础设施层，硬件层等。代码实现中可以是MVC分层，MVVC分层，MVVM分层等等。
第二，在分层模式中不止可以进行纵向分层，也可以进行横向分层，甚至还可以洋葱分层。具体的分层中还会有很多类似于反模式的形式出现，比如说跃层，比如说在一个大的分层中在分层。
针对这些分层方式作者举几个栗子。纵向分层的就像《Software Architecture Patterns》所说明的那样。分为：表示层、业务层、持久化层和数据库。 在之后会介绍到的管道过滤器模式中就可以看做是一个横向的分层。在还有洋葱式的分层模型，最直接的就是针对领域进行分析时使用的六边形架构，clean架构。并且在现实的代码框架上也得到了了应用，例如Python中的web框架Django。 再举一个反模式的例子，这个图是我在平常使用的一个图。从图虫可以看到跨层，在细分的方式进行架构设计。 特点 # 开发 # 过程管理（康威定律） 使用一人从顶到底的方式完成功能，或者使用按层隔离的方式都是可以实现系统的。不过这里面涉及到组织管理的模式。需要适应组织管理，或者组织管理适应方式进行。
可测试性 分层模式太多变体，无法评估。
可扩展性 分层模式太多变体，无法评估。
运维 # 可伸缩 分层模式太多变体，无法评估。
部署难易 分层模式太多变体，无法评估。
维护难易 分层模式太多变体，无法评估。
性能 # 因为分层模式通用性太强，没有办法去以一种方式评估他的性能。所以这里就粗略的说明一下。分层模式中如果使用方法调用的方式进行通信比使用线程间通信的方式高10倍，如果使用线程间通信的方式比使用进程间通信的方式高10倍，进程间通信的方式比主机之间通信的方式高10倍。
总结： # 不要把架构模式就当做是架构模式，可以在任何的层面上使用架构模式。 架构模式给我们提供了原则，就会又回到那句话《规则对于智者来说是指导，对于愚者来说是遵从》。所以，请铭记原则，而不是这里所说到的各种各样的形式。 在设计模式中有几个模式可以提升到架构模式层面上使用。例如：门面（Facade）模式，策略模式等。门面模式给我们在架构设计中提供了一种思路，就是OpenStack中的服务集群的方式。 现在国内软件界在流行分布式系统的：大中台概念。所以，我们可以在分层模式中体现出架构模式的优点。具体怎样实施可以根据具体的项目确定。 参考 # 《恰如其分的软件架构.风险驱动的设计方法》14.6 分层风格 演进式架构设计 Software Architecture Patterns</description></item><item><title>03 事件驱动架构模式</title><link>https://doks.netlify.app/architecture/03.architectural-pattern/03-%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/</link><pubDate>Sat, 22 Apr 2023 12:52:56 +0800</pubDate><guid>https://doks.netlify.app/architecture/03.architectural-pattern/03-%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/</guid><description>介绍 # 还是先举例子，在平常的生活中事件驱动架构也是比较常见的。一般情况下的人与人之间的沟通都是以一个人说一个人听的关系进行，并同时可以交换听者与说着。伴随着听者听到说者所表述的内容后，做出的心理，行为上的反应就是事件在接受者中的处理过程。
上面简单的说明了事件驱动的机制。我们从中找一些抽象出事件驱动架构模式的特点。在上面简单的例子中我们可以分析出说者和听着都是独立的个体，独立个体就有独立的思维方式以及处理结果。通过两者都能理解或者都能听懂的语言进行交流，双方都能理解的语言在计算机系统中可以定义为通信协议。双方是通过声音的方式进行沟通的，那么双方的通讯是需要在通信介质（空气）上进行的。
如上所述，我们总结出事件驱动架构模式的几个重要特点。
至少需要一个发送者和一个接受者。 需要在两者之间建立双方都可以理解的通信协议。 需要传播介质帮助信息的传递的过程。 在这里就有可能碰到很多问题。比如说：一个人自言自语，算不算事件驱动机制？一个人在台上演讲，台下做了很多人算不算事件驱动？在于不同语言的人沟通时中间介入的翻译算不算事件驱动？我使用电话和家人通话算不算事件驱动？我看电视剧算不算事件架构模式?
讲解 # 上面提到了很多的问题，其实这里涉及到比较多的现实编程中会遇到的问题。一个真正的事件驱动架构模式是不必要关心这些问题的。因为事件架构模式最重要的事产生事件和处理事件。只要专注于此即可，不必拘泥于这么多的情况。
事件驱动架构模式中的两件核心事情：产生事件和处理事件。接着分析这两个核心问题，怎样产生事件？怎样处理事件？
产生事件可以分为：
事件触发事件。在这里并不一定是同一种方式出发的事件再转发出去。例如，可以是用户从页面触发的事件，然后转换成消息队列中的消息事件，然后再转换成写库事件。它不必是从rest来的事件再转换成另外一个rest事件传递给其他的接收者。 定时事件。在很多情况下业务系统需要定时处理某些业务。 随机事件。随机事件是一类比较特殊的事件产生情况，但在一些特殊的情况下需要差生一些随机事件。混沌工程，MonkeyKing的场景下需要产生某些随机事件。 处理事件一般情况下不进行分类，因为基本上都是进行业务处理然后返回。就像早先在单体结构中，一个WEB服务接收到客户的HTTP事件之后进行处理类似。所以业务处理系统无法进行分类。不过与一般的事件处理不同的是事件驱动架构模式内定义了更多的消息通信方式：同步消息，异步消息。同步消息就是在接收者接收到消息之后处理消息并返回的过程中，发送者一直等待直到结果返回。异步消息则不同，异步消息在消息发送者发送完消息后就不等待，直接处理其他事务即可。
模式描述 # 最早之前在学习MFC的时候，就认为每个按钮，每个动作绑定一个事件处理函数的方式就是一种实践的处理方式。后来在浏览器上用JS监听鼠标，按钮动作时就又发现了一种事件驱动模式，并且现在流行的Nodejs把JS的单线程事件驱动模型给发挥的淋淋尽致。再有使用Socket通信时的Select，Poll也是标准的事件驱动模型，在Linux上还有专门的事件驱动库Libevent。可知道在Linux上找到一个用C语言写的库是非常非常难的（除了LibC）。可见事件驱动模式在计算机技术发展过程起到了多大的作用。
在现在流行的移动端开发中，也有Android消息机制，从Java层到Native层剖析，Android消息机制（一）：概述设计架构这样的事件驱动模型。然后配合FSM（有限状态机）影响移动系统的状态是非常强的一种架构模式。
在Java企业应用系统中也有spring events 和 eventbus帮助我们形成企业应用系统。而且借助工具可以在应用内部实现事件驱动，也可以在应用外部实现事件驱动。
业界有很多把事件驱动模式又划分为Mediator拓扑和Broker拓扑。这里我只接受Mediator拓扑。因为Broker拓扑只不过就是将事件处理系统级联起来，组成一个级联事件处理系统。我们大可以用管道过滤器架构模式来级联不同的事件。另外也因为架构模式是一种原则性或规则性的概念，所以，只需要介绍最纯粹的原则即可，不能介绍具体的实现。如果介绍具体实现会限制读者在接收信息时的接收到的元信息。
特点 # 开发 # 过程管理（康威定律） 事件驱动架构模式一个比较大的特点就是消息的可跟踪性弱，所以，需要考虑在哪里加入跟踪元素，跟踪元素的实现团队与使用事件驱动模式的团队之间的关系。
可测试性 因为事件驱动模式的事件可跟踪性弱的原因。在测试中需要以事件为判断因素时可测试性较弱，并且如果出现问题调查起来也比较困难。
可扩展性 因为使用分离关注点的方式隔离了两端，如果使用消息中间件进行隔离可以得到很好的可扩展性。
运维 # 可伸缩 变体比较多，有些变体可以适应伸缩，有些变体不适用伸缩。
部署难易 有些变体中有设计到多服务部署和服务发现的问题，需要在上线时进行配置。
维护难易 稳定性尚可，但是可跟踪性比较弱。所以维护难度比较高。
性能 # 这里需要看性能是按照那些标准进行计算。主体上来说，事件驱动架构模式对性能的影响不会太大。
总结： # 通信方式中单播，组播，广播都可以在事件驱动架构模式中使用。 可以在架构中使用独立的服务组件（消息中间件）完成消息的传递，也可以使用服务内部的事件驱动框架完成。 在涉及到服务部署多节点时，但某项业务需要只处理一遍时。可以借助外部的决策中心进行决策，由主节点完成处理，辅节点可以不处理。也可以使用调度中心进行调度。 参考： # 《恰如其分的软件架构.风险驱动的设计方法》14.11 发布-订阅风格 阿里巴巴在混沌工程领域的实践和思考 Software Architecture Patterns 构建事件溯源系统时犯的错误和恢复措施</description></item><item><title>04 微内核架构模式</title><link>https://doks.netlify.app/architecture/03.architectural-pattern/04-%E5%BE%AE%E5%86%85%E6%A0%B8%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/</link><pubDate>Sat, 22 Apr 2023 12:52:56 +0800</pubDate><guid>https://doks.netlify.app/architecture/03.architectural-pattern/04-%E5%BE%AE%E5%86%85%E6%A0%B8%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/</guid><description>上面提到的核心微服务系统群的概念，可以参加大中台的概念。但是它是更倾向于稳定，通用性的业务。它是经过高度抽象并提供原子操作的核心系统，就像微内核系统中内核。外部的所有内容都是以插件的形式插入到系统中。</description></item><item><title>05 微服务架构模式</title><link>https://doks.netlify.app/architecture/03.architectural-pattern/05-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/</link><pubDate>Sat, 22 Apr 2023 12:52:56 +0800</pubDate><guid>https://doks.netlify.app/architecture/03.architectural-pattern/05-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/</guid><description>以内部复杂度替换为外部复杂度。 管理成本极度上升。 微服务划分规则很难把控。</description></item><item><title>06 云架构模式</title><link>https://doks.netlify.app/architecture/03.architectural-pattern/06-%E4%BA%91%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/</link><pubDate>Sat, 22 Apr 2023 12:52:56 +0800</pubDate><guid>https://doks.netlify.app/architecture/03.architectural-pattern/06-%E4%BA%91%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/</guid><description/></item><item><title>07 命令查询指责分离模式</title><link>https://doks.netlify.app/architecture/03.architectural-pattern/07-%E5%91%BD%E4%BB%A4%E6%9F%A5%E8%AF%A2%E6%8C%87%E8%B4%A3%E5%88%86%E7%A6%BB%E6%A8%A1%E5%BC%8F/</link><pubDate>Sat, 22 Apr 2023 12:52:56 +0800</pubDate><guid>https://doks.netlify.app/architecture/03.architectural-pattern/07-%E5%91%BD%E4%BB%A4%E6%9F%A5%E8%AF%A2%E6%8C%87%E8%B4%A3%E5%88%86%E7%A6%BB%E6%A8%A1%E5%BC%8F/</guid><description>介绍 # 命令查询责任分离源于Bertrand Mayer设计的命令查询分离（CQS）原理。CQS声明一个类只能有两种方法：改变状态并返回void的方法和返回状态但不改变它的方法。后来经过Greg Young的发展与推广最终形成了现在的CQRS。
讲解 # 命令查询的责任分离(Command Query Responsibility Segregation，简称CQRS)模式包含着两部分：能够使改变模型的状态的命令和模型状态的查询。CQRS是DDD应用领域的一个模式，主要解决DDD在数据库报表输出上处理方式。
在DDD架构中，通常会将查询和命令操作分开，具体落地时，是否将查询和命令分开成为两个项目可以视情况而定，大多数情况下放在一个项目可以提高业务内聚性。也可以在逻辑层面上划分为两个不同的操作模型（Command和Query）但是在物理层面上还是使用同一个数据库进行。
对于CQRS来说最主要的是改变状态和获取状态的两类操作，只要将这两类动作分离的都可以称作是CQRS。这样拆离之后对于查询DTO和命令DTO就也可以分离出来。大多数时候，改变状态所需的数据在形式或数量上都不同于用户需要查询所需的数据。使用相同的模型来一起处理查询和命令会会导致模型膨胀，只依靠一种类型来操作所需的所有东西，模型复杂性也会增加，聚合大小通常会更大。
模式描述 # 对于命令查询职责分离模式可以有两种变种模式：CQRS，CQRS/ES。CQRS是对命令和查询使用不同的服务器。而CQRS/ES是使用溯源事件的方式将用户命令发送到读数据库中。Event Sourcing是由Martin Fowler提出，是将业务领域精髓（尤其是最复杂的）与技术平台的复杂性实现脱钩的天作之合。为什么要用Event Sourcing?或 Domain Events – 救世主
在这两种模式的选择中也分为有两个阵营：一个说你应该总是使用CQRS / ES，另一个说你应该只使用你的解决方案的一部分，并且只有当你需要具有高性能/可用性/可扩展性系统的高度并发系统时。您应该始终根据您的要求评估您的选择。
CQRS使我们能够使用不同的模型来改变状态和不同的模型来支持查询。通常写操作的频率低于读操作。 具有单独的模型和分离的数据库引擎允许我们独立地扩展查询端并更好地处理并发访问，因为读取端不再堵塞写入或命令端（在相反的情况下）。
对于读写数据库数据结构不一致或纯粹不一致的数据库的情况下，可以通过Event Sourcing的方式进行支撑。并且Event Sourcing的方式还可以进行消息记录。
特点 # 开发 # 过程管理（康威定律） CQRS/ES增加了平台的复杂度。需要在实施过程中以过程的方法解决复杂度增加造成的问题。
可测试性 CQRS/ES的测试点较多。并且因为复杂的增加可能会造成测试过程中问题反复。
可扩展性 CQRS/ES最主要的目标就是为了高性能/可用性/可扩展性系统而设计的。所以对于可扩展性的支持较好。
运维 # 可伸缩 CQRS/ES最主要的目标就是为了高性能/可用性/可扩展性系统而设计的。所以对于可伸缩性的支持较好。
部署难易 CQRS/ES系统中涉及到多服务部署的问题，需要在上线时进行配置。
维护难易 稳定性尚可，但是可跟踪性比较弱。所以维护难度比较高。
性能 # CQRS/ES最主要的目标就是为了高性能/可用性/可扩展性系统而设计的。所以对于性能的支持较好。
总结： # 在互联网高并发的情况下经常使用CQRS架构作为整体架构，然后再在CQRS内部使用其他的架构模式配合形成一套完整的架构。帮我们解决了很多关于性能、稳定性、数据拆分的问题。对于CQRS的特点可以总结为将用户操作与页面展示分离，可以使用静态化、缓存的方式解决读速度的问题。所以在CQRS中并没有限制在系统中使用同构数据库/数据源作为数据存储与查询做管理。在结合Event Sourcing的方式进行数据的更新操作。可以满足系统大量查询的情况。
参考 # CQRS 领域驱动设计模式、原理与实践 CQRS架构 解决CQRS中的复杂问题 最全面的CQRS和事件溯源介绍 - Software House ASC</description></item><item><title>08 仓库系统及知识库</title><link>https://doks.netlify.app/architecture/03.architectural-pattern/08-%E4%BB%93%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8F%8A%E7%9F%A5%E8%AF%86%E5%BA%93/</link><pubDate>Sat, 22 Apr 2023 12:52:56 +0800</pubDate><guid>https://doks.netlify.app/architecture/03.architectural-pattern/08-%E4%BB%93%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8F%8A%E7%9F%A5%E8%AF%86%E5%BA%93/</guid><description/></item><item><title>09 控制环路模式</title><link>https://doks.netlify.app/architecture/03.architectural-pattern/09-%E6%8E%A7%E5%88%B6%E7%8E%AF%E8%B7%AF%E6%A8%A1%E5%BC%8F/</link><pubDate>Sat, 22 Apr 2023 12:52:56 +0800</pubDate><guid>https://doks.netlify.app/architecture/03.architectural-pattern/09-%E6%8E%A7%E5%88%B6%E7%8E%AF%E8%B7%AF%E6%A8%A1%E5%BC%8F/</guid><description/></item><item><title>10 管道过滤器模式</title><link>https://doks.netlify.app/architecture/03.architectural-pattern/10-%E7%AE%A1%E9%81%93%E8%BF%87%E6%BB%A4%E5%99%A8%E6%A8%A1%E5%BC%8F/</link><pubDate>Sat, 22 Apr 2023 12:52:56 +0800</pubDate><guid>https://doks.netlify.app/architecture/03.architectural-pattern/10-%E7%AE%A1%E9%81%93%E8%BF%87%E6%BB%A4%E5%99%A8%E6%A8%A1%E5%BC%8F/</guid><description/></item></channel></rss>