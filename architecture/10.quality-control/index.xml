<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>10.质量管理 on</title><link>https://guowei1651.github.io/architecture/10.quality-control/</link><description>Recent content in 10.质量管理 on</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Sat, 22 Apr 2023 12:52:56 +0800</lastBuildDate><atom:link href="https://guowei1651.github.io/architecture/10.quality-control/index.xml" rel="self" type="application/rss+xml"/><item><title>01 概述</title><link>https://guowei1651.github.io/architecture/10.quality-control/01-%E4%BB%8B%E7%BB%8D/</link><pubDate>Sat, 22 Apr 2023 12:52:56 +0800</pubDate><guid>https://guowei1651.github.io/architecture/10.quality-control/01-%E4%BB%8B%E7%BB%8D/</guid><description>质量管理是一个过程。</description></item><item><title>02 性能优化 01 概述</title><link>https://guowei1651.github.io/architecture/10.quality-control/02-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9601-%E4%BB%8B%E7%BB%8D/</link><pubDate>Sat, 22 Apr 2023 12:52:56 +0800</pubDate><guid>https://guowei1651.github.io/architecture/10.quality-control/02-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9601-%E4%BB%8B%E7%BB%8D/</guid><description>背景 # 性能优化是技术治理的一部分，也是体现出技术人员真正价值的工作。从经验来看对于性能优化的认识与过程了解影响着系统的可持续发展的能力，正因如此性能优化就决定了系统是否可以有序的发展为一个优良的系统。在性能优化过程中对于系统中瓶颈的识别以及解决就成了性能优化的需求与目标。
性能优化会有几篇文章，分别说明性能优化的不同的内容，包括：环境定义，测试策略，测试过程，测试工具，优化办法。而对于性能优化来说整体步骤可以简单的划分为：$\color{red}{性能测试}$-&amp;gt;$\color{red}{性能分析}$-&amp;gt;$\color{red}{性能优化}$。
性能测试 # 性能优化过程中性能测试是发现问题的过程，是性能优化的先决条件。根据克努特优化原则：过早优化是万恶之源。在没有实际数据指导的情况下就开启优化过程是很不明智的过程，而且很容易方向跑偏。所以，必须在明确的数据作为支撑的情况下再开始进行性能优化过程。
虽然经常能够听到性能测试这个词，但是在这个词背后具体包含哪些内容，在未经过深入了解时也不可能一目了然的知道。这里就本着技术的深度决定着成就的高度的态度，重新挖掘一下性能测试的内容。
性能测试定义 # 性能测试是通过自动化的测试工具模拟多种正常、峰值以及异常负载条件来对系统的各项性能指标进行测试。
性能测试分类 # 下面一段来自百度百科中《性能测试》。根据不同的测试目的，性能测试可以分为多种类型，常见的有如下几类：
负载测试（Load Testing）：负载测试是一种主要为了测试软件系统是否达到需求文档设计的目标，譬如软件在一定时期内，最大支持多少并发用户数，软件请求出错率等，测试的主要是软件系统的性能。
压力测试（Stress Testing）：强度测试也就是压力测试，压力测试主要是为了测试硬件系统是否达到需求文档设计的性能目标，譬如在一定时期内，系统的cpu利用率，内存使用率，磁盘I/O吞吐率，网络吞吐量等，压力测试和负载测试最大的差别在于测试目的不同。
容量测试（Volume Testing）：确定系统最大承受量，譬如系统最大用户数，最大存储量，最多处理的数据流量等。
性能测试类型： # 下面一段来自百度百科中《性能测试》。性能测试中包含以下测试类型：
基准测试：比较新的或未知测试对象与已知参照标准（如现有软件或评测标准）的性能。
争用测试：核实测试对象对于多个主角对相同资源（数据记录、内存等）的请求的处理是否可以接受。
性能配置：核实在操作条件保持不变的情况下，测试对象在使用不同配置时其性能行为的可接受性。
负载测试：核实在保持配置不变的情况下，测试对象在不同操作条件（如不同用户数、事务数等）下性能行为的可接受性。
强度测试：核实测试对象性能行为在异常或极端条件（如资源减少或用户数过多）之下的可接受性。
容量测试：核实测试用户同时使用软件程序的最大数量。
性能评价：通常是和用户代表一起协作并且以多级方法执行的。
性能指标 # 《4.DevOps-4.度量指标&amp;ndash;0.度量指标(Metrics)》中已经描述过指标体系的建立与使用过程，而针对性能来说指标几乎已经固定为几个特殊的指标。不过还是有很多性能指标可以为性能分析提供很多帮助，在度量指标中我们讨论过指标类型可以分为：
Counter(计数器) 请求次数等 Gauge(测量器) 瞬时内存占用情况，CPU使用情况等。 Histogram(柱状图) 响应时间等。 Meters(码表) CPU Load数等。 Timers(计时器) 请求执行时长等。 其他 # 测试内容 具像化测试内容，例如对于区块链交易频次测试，那肯定是对整个区块链系统中数据同步的过程进行测试。对IoT环境进行测试就要理清设备接入时使用的协议是那种，做通信的就要对于系统的整体交换速率作为系统性能表现。
环境定义 测试环境与被测环境的定义确定着要优化的范围。
性能分析 # 性能分析是针对性能测试结果数据或着性能测试过程数据进行分析已找到性能瓶颈的方法。在性能测试完成后不可分析就代表着不可以进行优化。故结果的可分析性至关重要。现在性能分析已经有了长足的进步，有很多现成的程序可以帮助进行性能分析的工作。而且还可以可视化的展示分析结果。不过有些时候仍然需要进行人工的分析工作。性能分析的主要目标是可视化。
在借助现阶段流行的《可观测性》的实现方式之后，性能分析过程可以分为两类：APM，事后分析类。APM可以得到运行期间的运行情况，而对性能测试结果进行分析可以得到整体用户直观感受。一般情况下会结合两种方式进行。 性能优化 # 针对性能分析的结果进行优化，不管是找到业务问题还是技术问题都需要在这里输出相关的解决方案。在技术上有一些通用的调优方案，例如：阿里PTS上描述的**性能测试 PTS** &amp;gt; 性能测试基础知识 &amp;gt; 测试分析及调优，有赞的**一次假期故障引发的性能优化思考**。
总结 # 本文最主要说明的内容是性能优化的步骤以及步骤中可能的内容，还有很多细节未明确出来。例如：通用性能指标体系TPCC、SPEC、SAP SD，性能分析过程中的分析方法，性能调优过程中的验证过程等，性能调优架构级别调优方法等等。这些都会在后面的文章中进行更详细的讨论。
参考 # 过早优化是万恶之源——克努特优化原则 (Knuth&amp;rsquo;s optimization principle) 性能测试的概念 性能优化指南：性能优化的一般性原则与方法 常用性能测试指标解读与使用价值分析 一次假期故障引发的性能优化思考 【性能系列连载一】开篇：性能测试不可不知的“干货” Web「性能测试」知多少？ 性能分析 测试分析及调优</description></item><item><title>02 性能优化 02 性能评估</title><link>https://guowei1651.github.io/architecture/10.quality-control/02-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9602-01%E6%80%A7%E8%83%BD%E8%AF%84%E4%BC%B0/</link><pubDate>Sat, 22 Apr 2023 12:52:56 +0800</pubDate><guid>https://guowei1651.github.io/architecture/10.quality-control/02-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9602-01%E6%80%A7%E8%83%BD%E8%AF%84%E4%BC%B0/</guid><description>参考： # 性能数据分析时常用的统计方法 结果分析——性能测试学习笔记之 LoadRunner实战（6） jmeter性能测试重要指标以及性能结果分析</description></item><item><title>02 性能优化 03 规范</title><link>https://guowei1651.github.io/architecture/10.quality-control/02-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9603-%E8%A7%84%E8%8C%83/</link><pubDate>Sat, 22 Apr 2023 12:52:56 +0800</pubDate><guid>https://guowei1651.github.io/architecture/10.quality-control/02-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9603-%E8%A7%84%E8%8C%83/</guid><description>背景 # 一个架构师在平时工作中的重点注意的工作内容，就指明架构师所设计的产品架构的各方面特性。重点是数据库的架构师会将认为所有的工作核心就是数据库。重点在运营模式的架构师会认为所有的工作都是业务模式，运营方法。
再加上公司整体规划与方向有着非常明显的弱化技术的要求，架构师为了KPI、OKR放弃对产品架构的关心。就会造成整个公司少了架构师还是正常运转的情况。但是做一个真实的比喻，就如同下图一样：
少了技术型架构师的驱动的公司，就像上图一样。在不做变更的时候会使用的很正常，很稳定。但是如果稍微做一点变更整个系统就会进入崩溃状态。
每一个上线的产品，最主要的问题就是稳定性。为了应用能够稳定的提供服务，需要考虑很多内容。其中性能优化就是很重要的一个考虑项。性能优化是事后解决性能问题的方法，也有很多事前解决性能问题的方法。下面整体介绍性能优化的各个方面。
前期规划 # 在做一件事情之前，需要对这件事情有深入的认识与理解。然后基于认识和理解之后，对事情进行分析。分析后做出整体做事的规划或方法，然后再着手进行实施。
根据上面做事方式的指导。先对性能优化这件事情进行整体的规划。因为性能优化是项目实施过程中的一个步骤，所以在这里将说明在项目实施过程与性能优化之间的关系：
上图中浅蓝色部分是项目管理过程中要做的。深蓝色部分是性能优化设计到的步骤。蓝黑色部分是项目研发过程中的内容。在上产品环境后，肯定还需要各种各样的性能调优工作。例如：最近几年淘宝，京东都在做《全链路压测》的事情。所以这件事情需要一直做下去。
调研： 在整体项目实施规划中，非功能需求是一个很容易被忽略的部分。我们在做设计的一个基本依据就是非功能需求。有了它之后就可以估算出系统的整体性能要求大概范围。根据这个范围以及成本、时间约束就可以对系统中需要使用的技术，不使用的技术做出一个前期规划与设计。
针对产品型的性能数据评估。因为产品是已经上线的，所以，就可以根据现有的数据以及即将来到的运营策划数据进行性能数据的评估。这里就需要了解现有系统的使用情况数据，性能、稳定性表现情况之后。在作出相关的评估与设计。
设计： 设计阶段中根据前面收集的功能需求，非功能需求以及约束进行分析。分析出问题域中的核心问题，周边问题并将这些问题域的问题使用解决域提供的工具进行解决。解决域中的工具取决于架构师准备了那些工具。所以，在同一个问题域下，架构师的解决域确定了解决的方式。
因为性能是设计的依据，而性能有事从非功能需求来的。所以，对性能的交付也是需要有验收过程与验收方法的。在设计过程中需要将性能的验收方法，验收标准一并进行设计。
在产品型的性能设计过程中是有相对应的《性能验收软件架构》需要同时进行设计的。因为性能验收也是一套独立的软件系统。不过这套软件系统的目标就是帮助业务系统达到更高的性能指标而存在的。
开发： 开发过程中需要有规范的流程。从代码质量到交付方式，都需要一套标准出来。这样就可以有效的保证产品可以按时按点保质的方式进行交付。
监控： 在产品上线后运维比较关注的是APM，开发比较关注的是Tracing。监控的主要目的是为整个产品提供运行时数据。因为之前使用各种方法评估的内容，都是通过不准确手段获取到的数据。真实的数据就可以体现出之前评估节点所做的评估的偏差。可以利用这个偏差对系统进行调整。也可以利用这个偏差对评估数据进行校正，以使之后的评估中的数据会更加准确。
在提供产品的性能优化数据之外，还需要在系统中制定多维度的《度量指标》用来帮助之后进行各方面的评估。例如：用户转化率，产品销售率，热点页面等等。这些数据对之后的运维，运营都是有着非常大的帮助。
调优： 这个是前期调优，在项目制或者产品制第一次上线之前进行调优。还有后期调优，即产品上线之后根据使用情况对系统进行有针对性的调整。这两类调整都是以性能指标为输入，以达到性能指标要求为输出的。所以，在下面会对其中每一步再做详细讨论。
上线： 在调优过程中可能会对系统的局部架构，部署设计，数据库设计等作出调整。所以，在上线时需要需要考虑针对这些变化怎样才能将变化推到生产环境。基本上就考虑三种类型的升级：部署升级，数据升级，服务升级。
部署升级：部署过程进行了升级，比如说之前直接部署在逻辑环境上，现在变成部署在K8S上。 数据升级：数据结构发生了变更，需要有数据结构上的升级工作。 服务升级：服务内部实现发生了变化，需要同时运行老版本，并验证新版本的要求。 实施过程 # 性能调优和压力测试有很多内容都是可以重复利用的。例如测试时需要编写测试方案，测试计划。都可以在性能调优时使用。下面是性能调优的实施步骤：
性能目标： 不管做什么，第一步都是要明确需要做什么。性能目标在上面已经可以通过评估，实际数据等获取到性能目标。
环境准备： 现在的项目基本上都是用微服务的方式进行发布。所以环境准备阶段需要知道服务的具体部署情况。需要知道哪些开源组件需要部署，哪些服务需要配置。并且还需要设置性能环境和发送性能请求的测试环境之间的部署结构，使性能验证过程中受到的外界干扰最小化。
根据之前的目标对性能环境进行部署设计。在性能环境中的部署设计最终可以推到生产环境，但是需要针对性能指标进行相关的节点数评估，服务器上的硬件环境的评估。
需要根据并发量考虑性能环境和测试环境之间的带宽。以及测试环境的配置，以保证并发量可以达到性能要求的水平。
工具准备： 工具准备需要准备压测工具和监控工具。一些压测工具顺带就可以做监控的事情但是很多时候还是要进行独立准备。可以使用JMeter、Load Runner作为压测工具。也可以使用分布式性能测试工具控制多台主机进行测试。
监控工具要满足即可以检测到APM又可以检测到Tracing的内容。并且可以监控多项数据，监控主机性能，监控数据库性能，监控中间件性能等。
测试方法： 即需要验证的场景，以及验证这些场景所需要的脚本过程。在测试计划中会编写要测试的场景，并对场景中的请求内容进行设计。
优化确认： 已经有了工具，有了测试方法，并且有运行环境。就可以进行测试了，测试会形成测试结果。再针对测试结果有针对性的优化。例如某个方法执行时间过长，就可以想办法降低这个方法的执行时间。数据库查询时间过长就可以优化数据库查询。
在优化完之后，在对优化的内容进行一遍性能验证。如果验证通过则进行下一步。如果没有通过则，在此优化。往复循环这个过程指导性能验证通过，就可以进行进入到下一步。
功能测试： 在做完性能调优之后，还是需要再进行一遍功能验证的。因为在优化过程中可能对之前的功能产生了未知的影响。所以需要在性能调优完成之后再进行一遍功能验证。
总结 # 选用性能指标是非常重要的，这样一眼看过去就知道哪里有问题。在有目标的情况下进行，针对目标进行优化的效率在开发过程中猜测可能有性能问题的点并优化的效率要高的多。在实施这套方法时，也可以享受性能提升带来的成就感。
参考： # 如何制定 Java 性能调优标准？</description></item><item><title>02 性能优化 04 测试方法</title><link>https://guowei1651.github.io/architecture/10.quality-control/02-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9604-%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95/</link><pubDate>Sat, 22 Apr 2023 12:52:56 +0800</pubDate><guid>https://guowei1651.github.io/architecture/10.quality-control/02-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9604-%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95/</guid><description>参考 # 压力测试必知必会</description></item><item><title>02 性能优化 05 分析过程</title><link>https://guowei1651.github.io/architecture/10.quality-control/02-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9605-%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B/</link><pubDate>Sat, 22 Apr 2023 12:52:56 +0800</pubDate><guid>https://guowei1651.github.io/architecture/10.quality-control/02-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9605-%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B/</guid><description>参考： # 性能测试工具 一次性能压测及分析调优实践 性能分析与调优的原理 互联网常见架构接口压测性能分析及调优手段建议 Linux 性能诊断:荐书《图解性能优化》 超全整理！Linux性能分析工具汇总合集
Linux Tools Quick Tutorial</description></item><item><title>02 性能优化 06 性能优化</title><link>https://guowei1651.github.io/architecture/10.quality-control/02-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9606-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</link><pubDate>Sat, 22 Apr 2023 12:52:56 +0800</pubDate><guid>https://guowei1651.github.io/architecture/10.quality-control/02-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9606-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</guid><description>背景 # 本文是系列化文章中的一篇，系列文章描述性能优化的方方面面。本文主要说明在确定了需要优化的范围与方向之后怎样进行优化。
具体实践 # 对业务调优 对语言运行环境进行调优 尽量不使用线程 尽量不加锁 线程锁 分布式锁 减少对第三方的调用 数据库 dubbo接口、restful接口 使用缓存 拆分为异步 多节点（实例）部署 应用层多播，cdn 静态化 动态缓存技术之CSI,SSI,ESI 多地部署 参考： # 性能优化指南：性能优化的一般性原则与方法 如何开始性能优化 浅析互联网产品的性能优化 系统性能调优必知必会 性能优化：如何做好性能优化 常见性能优化策略的总结 如何回答性能优化的问题，才能打动阿里面试官？</description></item><item><title>07 可靠性设计 01 概述</title><link>https://guowei1651.github.io/architecture/10.quality-control/07-%E5%8F%AF%E9%9D%A0%E6%80%A7%E8%AE%BE%E8%AE%A101-%E4%BB%8B%E7%BB%8D/</link><pubDate>Sat, 22 Apr 2023 12:52:56 +0800</pubDate><guid>https://guowei1651.github.io/architecture/10.quality-control/07-%E5%8F%AF%E9%9D%A0%E6%80%A7%E8%AE%BE%E8%AE%A101-%E4%BB%8B%E7%BB%8D/</guid><description/></item><item><title>08 安全 01 概述</title><link>https://guowei1651.github.io/architecture/10.quality-control/08-%E5%AE%89%E5%85%A801-%E4%BB%8B%E7%BB%8D/</link><pubDate>Sat, 22 Apr 2023 12:52:56 +0800</pubDate><guid>https://guowei1651.github.io/architecture/10.quality-control/08-%E5%AE%89%E5%85%A801-%E4%BB%8B%E7%BB%8D/</guid><description/></item><item><title>09 微服务故障</title><link>https://guowei1651.github.io/architecture/10.quality-control/09-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%95%85%E9%9A%9C/</link><pubDate>Sat, 22 Apr 2023 12:52:56 +0800</pubDate><guid>https://guowei1651.github.io/architecture/10.quality-control/09-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%95%85%E9%9A%9C/</guid><description>故障为什么发生？ # 从单体服务发展到微服务之后就会发现故障是不可避免的了。从分布式计算的故障问题也会相应的加入到系统中。所以从单体服务到微服务之后就变成了不可避免的事情。具体可以从以下几个方面说明。
故障无处不在 # 《微服务设计》-11.规模化微服务 从统计学上来看，规模化之后故障将成为必然事件。
《生产微服务》-18.更多失效的可能性 大型分布式微服务系统包含大量持续变化的小型服务。对于这种复杂系统，我们要接受系统里的组建必然会失效的事实，而且它们经常的失效。
上面是两本书中说明的故障不可避免的问题。另外一个方面也会有软件的规模化的问题。从敏捷的角度看敏捷规模化成为问题才出现了SAFe，Less这种规模化问题解决方案。那么微服务规模化也是有类似的问题，规模化之后和之前几个服务的情况有质的区别。
微服务特点 # 而本质上，单体应用到微服务应用的转型就是应用的内部的高风险依赖转化为外部的低风险依赖的过程。是内部复杂度向外部复杂度的转换。因此，微服务架构改造所花费的成本大部分都在处理服务间的通信。
墨菲定律 # 事情往往会向你所想到的不好的方向发展，只要有这个可能性。即：你越害怕的事情越可能发生。
故障怎么发生？ # 从上一节看我们没有办法从事前确定故障并解决故障，那怎么在事中解决问题。就变成必须要做的事情。 惊群效应 # 连锁故障是由于正反馈循环（positive feedback）导致的不断扩大规模的故障。连锁故障可能由于整个系统的一小部分出现故障而引发，进而导致系统其他部分也出现故障。例如，某个服务的一个实例由于过载出现故障，导致其他实例负载升高，从而导致这些实例像多米诺骨牌一样一个以全部出现故障。
同质化问题 # 之前看过一种理论，同一个磁盘阵列中不能购买同一品牌，同一批次的磁盘组成磁盘阵列。原因是：从理论上来说，同一批次，又是同一使用环境，一起出问题的概率总要比不同批次的概率大点。 也就是在相似的初始条件下，又进行了相似的器件损耗的。造成同样问题的可能性也比较高。将这个问题推广到我们的软件系统中，会发现问题更加严重。因为我们的软件系统中服务都是同一个服务多实例部署的，这样就会发现服务不是相似的那么简单的了，服务是一样的。那么推导下去多实例中每一个服务对于同一件事情的处理方式，响应方式都是一样的。那么一个服务遇到一个错误，这类错误就会发生在所有的实例上。
资源共享 # 现在都在使用微服务进行服务的业务的管理与调度工作。对于服务来说服务的共享资源就成为不同业务抢占的资源，例如CPU资源，内存资源，数据库连接资源，线程资源，文件描述符资源等等。简单的说就是如果一个业务处理时间较长或卡住那么整体业务就可能被卡住，导致系统假死问题。
分布式系统故障 # http://www.xumenger.com/the-eight-fallacies-of-distributed-computing-20180817/ 分布式系统相关挑战：https://aws.amazon.com/cn/builders-library/challenges-with-distributed-systems/
故障的定位过程 # SRE俗语
不能将碰运气当成战略。
使用grafana+prometheus+alertmanager做可视化。使用apm这样的工具去做详细故障定位。
故障解决办法 # 故障注定会发生，那该怎么应对与解决？对于业界已经有了很多线程的解决方案。
优雅的服务降级 Graceful Service Degradation 变更管理 Change management 自愈 Self-healing 故障切换缓存 Failover Caching 重试机制 Retry Logic 限流与降级 Rate Limiters and Load Shedders 快速且独立地失败 Fail Fast and Independently 舱壁 Bulkheads 断路器 Circuit Breakers</description></item></channel></rss>