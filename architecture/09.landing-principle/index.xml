<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>09.落地原则 on</title><link>https://guowei1651.github.io/architecture/09.landing-principle/</link><description>Recent content in 09.落地原则 on</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Sat, 22 Apr 2023 12:52:56 +0800</lastBuildDate><atom:link href="https://guowei1651.github.io/architecture/09.landing-principle/index.xml" rel="self" type="application/rss+xml"/><item><title>01 概述</title><link>https://guowei1651.github.io/architecture/09.landing-principle/01-%E4%BB%8B%E7%BB%8D/</link><pubDate>Sat, 22 Apr 2023 12:52:56 +0800</pubDate><guid>https://guowei1651.github.io/architecture/09.landing-principle/01-%E4%BB%8B%E7%BB%8D/</guid><description/></item><item><title>02 快速失败</title><link>https://guowei1651.github.io/architecture/09.landing-principle/02-%E5%BF%AB%E9%80%9F%E5%A4%B1%E8%B4%A5/</link><pubDate>Sat, 22 Apr 2023 12:52:56 +0800</pubDate><guid>https://guowei1651.github.io/architecture/09.landing-principle/02-%E5%BF%AB%E9%80%9F%E5%A4%B1%E8%B4%A5/</guid><description>背景 # 软件研发过程中一个根本性的问题：**为什么要做软件（架构）设计？**在软件开发过程中软件设计可以分为两个方面：业务设计，技术设计。而业务设计关系着业务能力，业务服务内容，所以业务设计是必须的。也就是软件业务设计定义了软件要解决现实生活中的问题，如果没有这个问题我们也不需要去研发软件了。而对于软件设计来说技术设计是不是就变成一个可有可无的东西？
在大多数软件团队中都处于没有技术设计的阶段。而这样的阶段就会形成它独特的特点：
混乱无序 # 模块（服务）间关系混乱，服务的分层关系混乱，以业务为中心的代码直接将业务的复杂度与代码耦合过深导致从业务的混乱影响代码的复杂度。
没有技术目标 # 新的业务应该写在那个模块中，无谓的服务划分规则。不制定技术规范无法对于将来的变化做充分的应对方案。
不可扩展 # 每行代码都在处理业务，业务与业务之间纠缠的直接反应在代码上。导致一套代码只能适用于这个特定的业务，根本无法在其他地方复用。业务之间的纠缠导致代码的可修改行极度的差。
这几个特点对业务来说是致命的。严重的影响着业务的持续发展能力，不能支撑业务的发展。这是一种因为对于技术的忽略而反推到对业务发展的不负责的一种思路。因为技术是支撑业务的，但是在支撑业务过程中不考虑架构的事情就会反响的影响业务的持续发展。
而快速失败就是一个能够体现技术架构设计影响业务发展的一个例子。下面具体说明快速失败用怎样的方式影响业务的发展。
快速失败的层次 # 对于软件系统来说，系统化的管理是必不可少的。而快速失败也体现在系统化管理的各个层面上。这里我将应用快速失败的系统化管理的层面分为：业务规划层，系统层，服务间通信层，代码层。在每一层中都有它独特的快速失败方法。而在不同的层面间共享的Fail-fast原则有着一些共同的特点。
在Wiki上对于快速失败的定义：
在系统设计中，Fail-fast系统是指在接口处立即报告任何可能指示故障的情况的系统。Fail-fast系统通常设计为停止正常运行，而不是试图继续一个可能有缺陷的过程。这样的设计经常在一个操作中的几个点检查系统的状态，因此任何故障都可以早期检测到。Fail-fast模块的职责是检测错误，然后让系统的下一个最高级别处理错误。
它们的共同点就是在边界处进行处理并报错。以最快的速度响应，以提高性能与可靠性。
对于快速失败后，问题应该怎样解决？上图为在发生快速错误时的解决方案，在快速失败的情况去给各方一个快速反馈。以快速反馈的方式反馈出错误原因，这样可以更有针对性的进行问题解决工作。
业务规划层 # 在业界MVP的概念就是在业务规划层面上对于Fail-fast策略的最大体现。这意味着企业可以通过进行大胆的实验，以确定产品或战略的长期可行性，而不是谨慎行事，在注定要失败的产品、战略上投资数年。它成为了创业文化中的一种经典实践。
系统层 # 不允许将错误动作、异常数据在系统中传递，导致系统整体数据的污染。如果允许传播错误动作，异常数据，那么就会将错误传递到整个系统，从而影响系统的整体稳定性。而在系统层面上保证系统的可靠性和性能优越性，那么就必须让系统满足快速失败原则。
微服务层 # 任何的第三方都是不可信的。在这个过程中需要做到：怀疑第三方，防备使用方，做好自己。这样才可以防止故障，错误在微服务间传递。以快速检测、快速发现的方式检测到第三方的问题，并快速报错。并限制服务间下一次重试的时间，以最大限度的降低系统的不稳定性。
代码层 # 有人参与的地方都不能保证不出错，而开发人员编写的代码肯定也是会出错的。那么尽快的检测出错误并修复就成为了当务之急，所以在每个接口的第一部分就是需要业务层面合法性的判断。而且还需要在接下来的技术层面上的代码错误也尽快返回，以防止用户请求阻塞。技术错误导致资源（线程，内存，数据库）被占用的情况。
技术 # 上面基本上已经说明了在不同的层面上需要哪些快速失败的方法。这里主要进行快速失败技术方面的讨论。针对技术层面上可能需要考虑负载均衡器的快速失败，服务健康度检测技术，参数验证框架等内容。
实践 # Nginx 在Nginx上可以设置proxy_connect_timeout来标示最长可以接收的连接超时时间，如果服务超过这个时间就可以直接报错。以保证系统快速反馈的能力。可以设置upstream的keepalive和limit_req_zone、limit_req来控制流量。以达到快速失败的目的。 Spring retry # spring-retry在分布式系统中，为了保证数据分布式事务的强一致性，大家在调用RPC接口或者发送MQ时，针对可能会出现网络抖动请求超时情况采取一下重试操作。大家用的最多的重试方式就是MQ了，但是如果你的项目中没有引入MQ，那就不方便了，本文主要介绍一下如何使用Spring Retry实现重试操作。 Spring retry是使用aop的方式监听系统内发生的错误，并以重试的机制进行重试。与Spring Boot集成时使用@EnableRetry注解来启动重试服务。以代码形式的配置为：
RetryTemplate template = new RetryTemplate(); TimeoutRetryPolicy policy = new TimeoutRetryPolicy(); policy.setTimeout(30000L); template.setRetryPolicy(policy); Foo result = template.execute(new RetryCallback&amp;lt;Foo&amp;gt;() { public Foo doWithRetry(RetryContext context) { // Do stuff that might fail, e.</description></item><item><title>03 故障隔离 00 故障的传播方式与隔离办法</title><link>https://guowei1651.github.io/architecture/09.landing-principle/03-%E6%95%85%E9%9A%9C%E9%9A%94%E7%A6%BB%E6%95%85%E9%9A%9C%E7%9A%84%E4%BC%A0%E6%92%AD%E6%96%B9%E5%BC%8F%E4%B8%8E%E9%9A%94%E7%A6%BB%E5%8A%9E%E6%B3%95/</link><pubDate>Sat, 22 Apr 2023 12:52:56 +0800</pubDate><guid>https://guowei1651.github.io/architecture/09.landing-principle/03-%E6%95%85%E9%9A%9C%E9%9A%94%E7%A6%BB%E6%95%85%E9%9A%9C%E7%9A%84%E4%BC%A0%E6%92%AD%E6%96%B9%E5%BC%8F%E4%B8%8E%E9%9A%94%E7%A6%BB%E5%8A%9E%E6%B3%95/</guid><description>背景 # 在分布式软件系统中解决可靠性问题可以分为两个方向：主动预防故障发生，防止故障在系统中扩散。现阶段大部分关于分布式系统的可靠性方面的研究还是集中在怎样阻止故障发生，以预防故障的发生而提高系统的可用性。现在互联网行业中逐渐的发展壮大，也伴随着互联网软件的体系的故断壮大。在不断壮大的软件系统中，故障成为不可避免的事情。而在发生故障时怎样控制故障范围最小就成为现阶段要管理的问题。
在这个过程中有几个关键概念需要献说明以下：
故障隔离 # 故障隔离指的是在航空器上实时工作环境下，对系统或设备的分系统各部分分别判定其正常工作状态，缩小到最后判定有故障的分系统或部分的技术措施。
连锁故障 # 连锁故障指由于电力系统电气量间的相互关联，当某一故障发生时随之引发的其他故障。
故障树分析法 # 其实这个概念是为了说明故障传播的概念。 故障树分析（FTA）一开始是由贝尔实验室的H.A.Watson所发展的，一开始是因为美国空军第526 ICBM系统群的委托，要评估义勇兵一型洲际弹道导弹(ICBM)的发射控制系统。之后故障树分析开始成为可靠度分析者进行失效分析的工具。
根因分析 # 根本原因分析（RCA）是一项结构化的问题处理法，用以逐步找出问题的根本原因并加以解决， 而不是仅仅关注问题的表征。
故障传播方式 # 在解决故障传播的问题时，确定故障传播的方式是确定问题原因的一种方式。这里是对与作者现阶段认识到的故障传播方式。主要可以分为：惊群效应，同质化问题，资源共享。
惊群效应 # 以下内容是《SRE》中关于连锁故障的描述：
连锁故障是由于正反馈循环（positive feedback）导致的不断扩大规模的故障。连锁故障可能由于整个系统的一小部分出现故障而引发，进而导致系统其他部分也出现故障。例如，某个服务的一个实例由于过载出现故障，导致其他实例负载升高，从而导致这些实例像多米诺骨牌一样一个以全部出现故障。
假设前端服务器在集群A中正在处理1000QPS的请求。如果集群B出现故障，发往集群A的请求上升至1200QPS。集群A中的前端服务无法处理这么多请求，由于资源不够等原因导致崩溃、超时，或者出现其他异常情况。结果，集群A成功处理的的请求远地域之前的1000QPS。
同质化问题 # 之前看过一种理论，同一个磁盘阵列中不能购买同一品牌，同一批次的磁盘组成磁盘阵列。原因是：
从理论上来说，同一批次，又是同一使用环境，一起出问题的概率总要比不同批次的概率大点。
也就是在相似的初始条件下，又进行了相似的器件损耗的。造成同样问题的可能性也比较高。将这个问题推广到我们的软件系统中，会发现问题更加严重。因为我们的软件系统中服务都是同一个服务多实例部署的，这样就会发现服务不是相似的那么简单的了，服务是一样的。那么推导下去多实例中每一个服务对于同一件事情的处理方式，响应方式都是一样的。那么一个服务遇到一个错误，这类错误就会发生在所有的实例上。
资源共享 # 以下内容是《架构即未来》中关于故障隔离架构的描述：
在我们的实践中，经常吧故障隔离架构比喻成泳道（Swim lane）。我们相信这个比喻生动地描述了希望在故障隔离中实现的画面。对于游泳选手，泳道既代表了故障也代表了引导。障碍物的存在是为了确保游泳选手产生的波浪不进入另一个泳道，干扰其他游泳选手。在比赛中，这有助于确保选手不受干扰，避免不恰当地影响每个游泳选手赢得比赛的概率。
现在都在使用微服务进行服务的业务的管理与调度工作。对于服务来说服务的共享资源就成为不同业务抢占的资源，例如CPU资源，内存资源，数据库连接资源，线程资源，文件描述符资源等等。简单的说就是如果一个业务处理时间较长或卡住那么整体业务就可能被卡住，导致系统假死问题。
故障传播检测 # 系统监控就是为了实时的了解系统的运行状态而建设的。那针对故障传播的监控或着感知系统现阶段还是很少的，基本上没有搜索到相关的资料信息。对于在故障传播过程中去检测都是需要加入智能运维的内容。通过智能运维的各项指标监控输入，然后通过AI系统的判断形成故障传播告警。
除了故障发生传播过程中需要感知故障传播，还有就是在验证环境中对故障传播模型或者根本原因分析进行相关的工作。在这个过程中可以使用预生产环境中进行实践工作。使用连锁故障测试的方式对业务故障的扩散进行发现与管理工作。
tcpcopy # 使用tcpcopy进行线上流量copy到预生产环境中进行线上流量的测试。
故障注入 # 使用故障注入的方式故障传播方式的研究工作。
混沌工程 # 混沌工程就是随机的注入问题。
数据可视化 # 线上环境上对于调用链的展示，以及对于系统指标中的可视化展示需要可以一眼看到是否发生故障。发生了故障之后直接看到故障点在哪里。
故障传播解决 # 现阶段大部分系统都忽略了故障传播问题的解决，所以，作者见到的系统中绝大部分故障都是因为传播的问题而导致系统整体瘫痪的。几乎所有的故障都会传播到整个系统中形成系统整体瘫痪的问题，这个就是系统不稳定的问题。使用方法论引导解决方案的思路进行落地工作。
原则 # 减少共享 其实严格来说故障隔离是不允许共享的。他的思路是即然是一个隔离的组件，那么这个组件应该包括所有的依赖项，在没有其他组件的情况下自身可以运行的。甚至说都不需要通讯。但是，实际开发中是没有绝对的隔绝的，一些系统特别是核心系统是需要沟通的。所以我们建议是减少共享。如果需要共享，最好是用解耦合的方式共享。例如：消息队列的方式和其他的组件或者系统进行通信。这样既保证了通讯也保证了系统的独立性不受影响。 不跨越系统边界 就如上面提到的系统边界就好像泳道一样，系统是不能跨越边界到达其他系统的。如果需要通讯需要，按照第一条中提到的通过中间件的方式来完成。为什么在这里要特别提出来，是因为被放在隔离区域中的系统通常都针对特定的客户，特定的业务，特定的组件。如果他们和外界的系统有过多的交集，就明显无法达到隔离的效果。 所有的交易只能发生在系统边界内 实际上需要完成的是，所有的交易闭环都在系统边界内完成，交易中的任何环节都不要出现在系统之外。举几个例子：和利益相关的业务，经常出现故障的业务，用户边界明显的业务。 故障解决方法 # 资源隔离 对于抢夺资源造成服务内，服务间的故障传播还是故障传播的原因。所以需要对线程池隔离，数据库连接池隔离，消息通道隔离等都需要进行管理。 服务降级 现在对于微服务中的一个服务中，对于接口降级还是对于服务降级是需要有固定的定义的。因为小范围故障的时候可能是某个接口在线上返回时间超长，卡顿的问题。需要可以进行故障降级的业务关联性的内容。 服务容错 在其他服务发生错误时需要进行友好的错误回复，并在调用需要进行业务过程的管理定义在业务流程中哪些业务流程是可以忽略的，哪些是必须要的。怎样通过BASE的问题进行管理。 间接依赖 访问中间服务，而不是直接访问对方服务。尽量减少直接耦合。（rpc就是直接耦合的一个特例） 技术解决方案 # 上面已经说明了上层理论，并以上层理论进行了具体可落地方向的划分工作。落地方向定义了之后，这里定义这些落地方向下现在可行的一些技术解决方案内容。</description></item><item><title>03 故障隔离 01 技术实现</title><link>https://guowei1651.github.io/architecture/09.landing-principle/03-%E6%95%85%E9%9A%9C%E9%9A%94%E7%A6%BB01-%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0/</link><pubDate>Sat, 22 Apr 2023 12:52:56 +0800</pubDate><guid>https://guowei1651.github.io/architecture/09.landing-principle/03-%E6%95%85%E9%9A%9C%E9%9A%94%E7%A6%BB01-%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0/</guid><description>背景 # 需求方向 # 技术实现 # 总结 # 参考 #</description></item><item><title>04 无状态服务</title><link>https://guowei1651.github.io/architecture/09.landing-principle/04-%E6%97%A0%E7%8A%B6%E6%80%81%E6%9C%8D%E5%8A%A1/</link><pubDate>Sat, 22 Apr 2023 12:52:56 +0800</pubDate><guid>https://guowei1651.github.io/architecture/09.landing-principle/04-%E6%97%A0%E7%8A%B6%E6%80%81%E6%9C%8D%E5%8A%A1/</guid><description/></item><item><title>05 反面模式</title><link>https://guowei1651.github.io/architecture/09.landing-principle/05-%E5%8F%8D%E9%9D%A2%E6%A8%A1%E5%BC%8F/</link><pubDate>Sat, 22 Apr 2023 12:52:56 +0800</pubDate><guid>https://guowei1651.github.io/architecture/09.landing-principle/05-%E5%8F%8D%E9%9D%A2%E6%A8%A1%E5%BC%8F/</guid><description>背景 # 参考 # 反面模式</description></item><item><title>06 架构治理</title><link>https://guowei1651.github.io/architecture/09.landing-principle/06-%E6%9E%B6%E6%9E%84%E6%B2%BB%E7%90%86/</link><pubDate>Sat, 22 Apr 2023 12:52:56 +0800</pubDate><guid>https://guowei1651.github.io/architecture/09.landing-principle/06-%E6%9E%B6%E6%9E%84%E6%B2%BB%E7%90%86/</guid><description>参考 # 第 8 章 架构能力框架 企业架构研究总结（38）——TOGAF架构能力框架之架构能力建设和架构治理</description></item><item><title>06 架构治理</title><link>https://guowei1651.github.io/architecture/09.landing-principle/07-%E6%9E%B6%E6%9E%84%E8%90%BD%E5%9C%B0/</link><pubDate>Sat, 22 Apr 2023 12:52:56 +0800</pubDate><guid>https://guowei1651.github.io/architecture/09.landing-principle/07-%E6%9E%B6%E6%9E%84%E8%90%BD%E5%9C%B0/</guid><description>架构设计包含的内容以及包含的内容的落地 # 业务架构 # 应用架构 # 数据架构 # 技术架构 # 开发 # 已框架，库方式进行落地。
运维 # 以开源组件使用的方式进行落地。
反康威定律 # 以架构设计拆分出的组件进行团队拆分以及团队边界的制定。
全功能团队：并不代表团队要懂公司内所有的业务。而是团队有各个方向的人参与
功能特性团队：为特性功能而组织的团队。
参考 #</description></item></channel></rss>