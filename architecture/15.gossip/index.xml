<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>15 闲聊 on</title><link>https://guowei1651.github.io/architecture/15.gossip/</link><description>Recent content in 15 闲聊 on</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Sat, 22 Apr 2023 12:52:56 +0800</lastBuildDate><atom:link href="https://guowei1651.github.io/architecture/15.gossip/index.xml" rel="self" type="application/rss+xml"/><item><title>01 论代码之熵</title><link>https://guowei1651.github.io/architecture/15.gossip/01-%E8%AE%BA%E4%BB%A3%E7%A0%81%E4%B9%8B%E7%86%B5/</link><pubDate>Sat, 22 Apr 2023 12:52:56 +0800</pubDate><guid>https://guowei1651.github.io/architecture/15.gossip/01-%E8%AE%BA%E4%BB%A3%E7%A0%81%E4%B9%8B%E7%86%B5/</guid><description>前言： # 本文为2013年3月写的一篇文章。现在看还是有意义的，所以转载到这里。几十年前的《人月神话》中说的焦油坑，现在还在不断的重复出现。
原文： # 1850年，德国物理学家鲁道夫克劳修斯首次提出熵的概念，用来表示任何一种能量在空间中分布的均匀程度，能量分布的越均匀，熵就越大。在克劳修斯看来，在一个系统中，如果听任它自然发展，那么能量差总是倾向于消除。
以上所说的熵的定义可能让大家有点不知所谓。其实代码的混乱程度可以认为是一种熵。代码某一处在书写过程中没有清晰的层次，代码的简洁度不够。会影响周边的代码趋向于混乱。
如果做一件事情总喜欢绕过来绕过去然后再以别扭的处理方式处理整件事情。往往这类代码会出更多的问题。因为如果每千行代码平均出50个BUG，那么实现同样的功能混乱代码所用的行数远超过结构清晰的代码。所以，代码多，BUG就会多。最好的代码就是清晰代码结构降低代码量。
举个栗子： # 把货物放到该位置（货物，位置） { 将货物从仓库门口搬到位置 把货物放进去位置 看看有没有空位 将货物信息提交到仓库记录中 } 存储货物(货物) { 位置 = 找个适合货物的位置（货物） 看看临时仓库上有没有位置 看看临时仓库上都是什么货物 把货物放到该位置（货物，位置） 获取放到临时仓库上了吗？ 这个货位上都存了什么货物？ } 这只是一个简单的例子，突出了结构混乱代码。其实在现实中比例子里面的混乱程度更甚的代码者比比皆是的。写这样代码的人，能说他办错了事吗？不能，因为程序把该做的事情都做了。而且还需要鼓励这些程序员，因为他们再最快的时间内为你出了功能，满足了系统上线、Bug修复等等问题。
那在这种情况下怎么进行代码维护？ 怎么保证系统的可用性？怎么在团队间进行知识传递？
从各种角度思考后，你会发现没有任何一种方法能够约束程序员写出直截了当，结构清晰的程序。所以，程序员写代码的时候除了“高压线”不敢碰，剩下的什么都敢做。对于要求一个程序员自觉的学习逻辑学，并系统化的认识整个项目、对系统架构有完整理解再去写代码是几乎是不可能的。 更不用提优雅的处理整个过程。
问题后果： # 不断地传染其他代码： # 我们在分析一下这种类型的代码会带来的后果。根据熵的方式，这种代码会传遍整个项目。例如：我现在要维护这段代码。需要新加一个将货物通过某种方式可以移动到仓库门口的方法也记录到仓库记录中。
我需要先读懂这段代码。因为代码结构问题，读懂代码是比较费筋的。花了很大功夫读懂代码后发现其实功能很简单。 了解了代码的处理过程后，就是确定修改位置。由于各种原因（主要是不愿意承担由于修改代码结构造成故障的责任）是不会修改原有代码的结果的。也就是前例中应该将“将货物信息提交到仓库记录中”这个处理过程移动到“存储货物”的处理中。然后就会修改成： 把货物放到该位置（货物，位置） { 将货物从仓库门口搬到位置 把货物放进去位置 《do something》 看看有没有空位 将货物信息提交到仓库记录中 } 将代码添加到上一步确定的位置。 通过以上三步的维护过程，可以看到一个开发过程的缩影。在实际的项目开发与维护阶段进行着一遍遍重复着，随着这一遍一遍的重复代码就会陷入了无休止的混乱中。说句不好听的最终这些代码只能按坨算，一坨根本没有层次，混乱的代码。好多年前有一个高人除了一本叫做《人月神话》的书，里面描述的焦油坑真是异曲同工。
伴随着混乱上线： # 对项目的业务处理过程思路不清晰导致代码多，代码多就BUG多。但是，上线时间、交付计划等都会是Deadline。各种各样的计划在催促着尽快上线，尽快抢占市场。所以，在某种妥协下系统就会带着这些代码上线。
这些代码都出现在模块内部。因为在模块间有强制性的接口约束。所以模块间关系还是比较清晰的，但是在多次添加新功能后模块间也会出现关系混乱的情况。比如在项目中要新加一个功能，其中A模块可以将消息M发送给B模块或者C模块，在架构的层次结构中是ABC，就有架构不清晰的程序员，三个负责人商量后，A直接将消息M发送给C。原因是B收到消息后不做操作直接传给C。这样更好就可以一月省个好几万去请架构师了。
总结： # 再结合软件过程说说混乱代码必定会出现在发布版本中的原因：
大家习惯在没有详细设计的情况下写代码，然后再从代码推导出详细设计。也就是说写代码的人根本就没有想过那些处理可以归类到一起，那些纯粹就不是一类。 写完代码之后不管是组织review还是同行评审。那个会提出代码结构有问题。不提出代码结构问题的原因有1.以一句没时间改结构为由拒绝了这个建议。2.他还在为他那一坨混乱代码发愁呢。还想不要被你提出代码结构有问题要他改结构呢。 客户 and 领导要的只不过就是一个可以完成任务并且少出bug的代码，没人会花费时间去重构。 对项目的业务处理过程思路不清晰导致代码多，代码多就BUG多，BUG多的人就得天天加班。加班多就被领导看见的多，领导看见多就认为BUG多的人勤劳，然后就BUG多的人就加薪升值了。然后思路清晰的就被催了。然后思路清晰的就会向“该”发展的方向发展。然后所有的人都会向着BUG满天飞的境界去努力。这样必然形成恶性循环。 综上，说明了混乱代码的出现原因，以及它是必然出现的原因。结果就是陷入混乱代码的泥沼，无法自拔。因为时间都被修复混乱代码带来BUG全部沾满。没有时间思考，学习，休息。
提出解决办法以供参考： # 程序员必须学习设计模式，有助于代码结构清晰。 先写设计（哪怕只有一页纸），然后编码。让你想清楚每一步该怎么做之后再去做。也可以边写设计边写代码。如果没有设计就写代码，那就需要想清楚模块的输入是什么，输出是什么，处理过程是什么。将它们各自封成不同的函数，然后再一个函数内调用这三个函数。这样就清晰的告诉读代码的人，你的过程是什么样的。 进行公司文化导向。奖励做出高质量review的人，而不是处罚写错代码的人。这样会鼓励做review的人，并形成一种对立关系。只有有了对立关系才能形成高质量的产品。</description></item><item><title>02 帮Stack-Overflow评估一下性能指标</title><link>https://guowei1651.github.io/architecture/15.gossip/02-%E5%B8%AEstack-overflow%E8%AF%84%E4%BC%B0%E4%B8%80%E4%B8%8B%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/</link><pubDate>Sat, 22 Apr 2023 12:52:56 +0800</pubDate><guid>https://guowei1651.github.io/architecture/15.gossip/02-%E5%B8%AEstack-overflow%E8%AF%84%E4%BC%B0%E4%B8%80%E4%B8%8B%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/</guid><description>背景 # 今天在 高效开发运维 的微信公众号上看到一篇文章《Stack Overflow：我们是如何做监控的》原文是Nick Craver编写的、由谢丽翻译的。Nick Craver是Stack Overflow的架构师，在这里感谢原文作者以开放的态度描述了Stack Overflow的内部架构与性能。感谢高效开发运维的翻译与分享。
Stack Overflow是一个与程序相关的IT技术问答网站。国内应该有90%以上的程序员是上过Stack Overflow，如果不记得或者不知道可能是在不经意间就被Baidu导流到Stack Overflow上。从这篇文章内我大概体会到Stack Overflow使用的是.Net技术栈，并且在.Net技术栈上使用了各种开源组件，而且Stack Overflow也开源了很多在.Net技术栈下的监控类的软件。
原始数据 # 原始文章： # 一个技术人员要成长、要经验，不仅仅是通过自己不断的摸索，还需要了解业界大佬们都是怎么解决他们的问题的。所以需要不断的了解业界大佬们的技术动向，在了解一个大型网站肯定是看这个大型网站的底层架构以及处理方式。所以，我就根据这篇文章下面的原文地址找了其他的文章。有三篇文章引了我的兴趣：
Stack Overflow: The Architecture - 2016 Edition Stack Overflow: The Hardware - 2016 Edition Stack Overflow: How We Do Deployment - 2016 Edition
部署结构： # 这三篇文章主要说明了2016时Stack Overflow的各项内容。本文中主要是根据这三篇文章进行一些数据的分析并将原始数据记录在这里。
部署结构图如上图所示，在这里各个服务的情况如下：
编号 服务 节点个数 1 Microsoft SQL Servers 4 2 IIS Web Servers 11 3 Redis Servers 1 4 Tag Engine servers 3 5 Elasticsearch 3 6 HAProxy 2(Web Service) + 2(CloudFlare) 硬件结构： # 软件服务的前期规划和软件服务持续发展过程中都会针对容量，运维进行规划与设计，在这方面Stack Overflow对硬件的规划和考虑重点包括：硬件弹性的问题，存储，内存，计算，网络，冗余，电源。在这方面Stack Overflow非常喜欢Dell的服务器，在这里并且配合SSD进行数据中心硬件基础的规划：</description></item><item><title>03 记一次Dubbo升级</title><link>https://guowei1651.github.io/architecture/15.gossip/03-%E8%AE%B0%E4%B8%80%E6%AC%A1dubbo%E5%8D%87%E7%BA%A7/</link><pubDate>Sat, 22 Apr 2023 12:52:56 +0800</pubDate><guid>https://guowei1651.github.io/architecture/15.gossip/03-%E8%AE%B0%E4%B8%80%E6%AC%A1dubbo%E5%8D%87%E7%BA%A7/</guid><description>背景 # 公司有一批15年左右实现的中台服务，当时使用的是JDK1.7+Gradle3.7实现的。这套微服务现在还是公司的业务主力，经过5年做左右的积累这些服务已经复杂的不可修改了。基于此公司准备对这批服务进行重构。重构的第一步肯定是进行技术升级。
过程 # 在进行技术升级的时候，公司对微服务进行技术升级的时候规划了几个步骤：
升级JDK。将JDK从1.7升级到1.8。 升级Dubbo。将Dubbo从2.5.3升级到2.7.3 升级到Spring Cloud。 使用容器管理服务。 上云原生应用。 做好计划之后，进行具体的升级工作：
进行JDK的升级 修改Gradle的build文件中的Jdk版本到 sourceCompatibility = JavaVersion.VERSION_1_8 targetCompatibility = JavaVersion.VERSION_1_8 然后进行编译，编译完发不到测试环境都挺顺利的。在测试环境上运行起来之后就发现：
java.lang.ClassNotFoundException: javassist.ClassPath 调查发现Dubbo2.5.3使用的org.javassist的包版本是3.15.0-GA。而这个版本在JDK1.8上不可运行。这出发了一个不可接受的问题，Dubbo2.5.3不可以在JDK1.8上运行。一般开源的服务都会对不同的JDK版本进行适配与支持，现在Dubbo2.5.3已经突破了底线了。
既然发现了这个问题，那就把第二步要做的升级Dubbo的事情一起做了吧。对Dubbo进行升级，升级到2.7.3版本：
修改gradle的build文件中的Dubbo到2.7.3: com.alibaba:dubbo:2.5.3 -&amp;gt; org.apache.dubbo:dubbo:2.7.3 修改Dubbo的xml配置文件中 http://code.alibabatech.com/schema/dubbo -&amp;gt; http://dubbo.apache.org/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd -&amp;gt; http://dubbo.apache.org/schema/dubbo/dubbo.xsd 修改Dubbo配置中的。因为logger从下升级的话可能不可使用，所以需要使用制定logger。 &amp;lt;dubbo:application name=&amp;quot;uc&amp;quot; logger=&amp;quot;slf4j&amp;quot;/&amp;gt; 修改代码中使用dubbo的代码 com.alibaba.dubbo.common.utils.StringUtils com.alibaba.dubbo.common.utils.CollectionUtils 到此就可以跑起来了。然后升级的服务和其他的服务之间的rpc通信也没有断。所以在这个过程中可以看到dubbo版本之间是可以兼容的。
在跑了两天之后发现一个问题，在做一个业务的时候无缘无故的发生了rollback问题。所有的异常在代码中都已经try-catch了，为什么会发生rollback问题呀。而且还是在两个服务通过rpc之间传递了rollback异常：
[DubboServerHandler-0.0.0.0:20880-thread-305] [ERROR] [o.a.d.r.f.ExceptionFilter$ExceptionListener] - [ [DUBBO] Got unchecked and undeclared exception which called by 0.0.0.0. service: cn.thinkjoy.uc.service.business.IUserService, method: saveUser, exception: org.springframework.transaction.UnexpectedRollbackException: Transaction rolled back because it has been marked as rollback-only, dubbo version: 2.</description></item><item><title>04 我为什么开始不推荐RPC</title><link>https://guowei1651.github.io/architecture/15.gossip/04-%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BC%80%E5%A7%8B%E4%B8%8D%E6%8E%A8%E8%8D%90rpc/</link><pubDate>Sat, 22 Apr 2023 12:52:56 +0800</pubDate><guid>https://guowei1651.github.io/architecture/15.gossip/04-%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BC%80%E5%A7%8B%E4%B8%8D%E6%8E%A8%E8%8D%90rpc/</guid><description>背景 # 国内互联网公司在选择微服务体系时有两种成熟的解决方案可以选择：Spring Cloud、Apache Dubbo。正所谓选择越多烦恼越多，公司对于技术体系进行选型时就会有比较大的分歧。
也有开发团队结合两者的优点进行业务的开展工作。使用RPC的方式进行内部关系管理，使用Restful作为接口对外暴露的方式进行。这样可以结合不同的特点进行相关的接口的提供。
这里简单的列出来两种方式的优点：
RPC优点：
长链接减少建立连接时的资源消耗。 二进制形式传输，传输效率高。 序列化、反序列化效率高。 不需要认证。 Restful优点：
通用负载均衡能力。 基于资源的管理。 需要认证。 原因 # 两种方式各自有各自的优点。那么标题中为什么写不推荐使用RPC方式呢？作者本着只有放错位置的技术，没有不对的技术的原则。对RPC在企业级应用中的不足来说明一些问题。
不推荐的原因：
耦合问题 刚开始使用Dubbo大家都会很容易的接受Provider和Consumer的jar包方式进行服务的管理工作。而慢慢的逐渐深入使用会逐渐的体会到Dubbo的API JAR包变成了一种约束。这样就非常间接，不明显的将Provider和Consumer绑定在一起。如果其中一方出现问题，就会造成另外一方的一些问题。很难通过中间件对服务间耦合进行拆离。 这个问题非常重要，它会直接导致后面所有的问题。
语言锁定 微服务的一个准则就是每个服务可以独立的演进，独立发展。可以通过不同的编程语言对服务进行编写。而Dubbo和类似的RPC实现方式使用Jar包的方式发布接口，那么就只能使用JVM上语言进行Jar的解析与加载工作。导致必须使用相同的语言进行rpc接口的调用。
上下文传递 Http是一种无状态服务，那并不代表RPC必须是一种无状态服务。在Http协议通过不断的发展在协议中传递了一些有状态的上下文信息，这样可以为服务提供一些有状态的信息以便在业务处理过程中使用。而RPC是一种更加纯粹的无状态服务，它没有标准化的规范导致不可能形成完善的解决方案。在Dubbo中可以借助多种方式进行上下文的传递工作，不过实现起来比较复杂。其中包括：Dubbo 上下文信息，事件通知，协议扩展
版本兼容问题 向下兼容问题对于每个软件来说都是一个非常棘手的问题。一方面我们需要让我们的软件持续的发展，另一方面需要兼容之前的代码。解决这个问题JS上解决的很好，每一个JS的函数没有固定的参数个数，没有固定的参数类型。这样相当于用业务来处理版本的兼容型问题。现在Dubbo上如果需要对接口进行新加或者变更的时候就会发现需要重新发布Dubbo API的Jar包。这样对于Provider和Consumer都是工作负担。使用版本号控制Dubbo API版本号时就得进行多服务实例启动。这个问题在Dubbo中没有很好的解决。兼容性
负载均衡就剩下一种方案：客户端负载均衡。 对于负载均衡来说Dubbo直接使用了客户端负载均衡的策略完成，直接摒弃了服务端负载均衡的可能行。这种情况下对于负载均衡的动态控制与动态管理工作就会形成问题。
发布过程支撑问题 线上发布一般基于切留的方式进行灰度发布，而对于长链接的Dubbo。不能很好的支撑蓝绿发布，灰度发布方式。 服务治理和配置管理,在线运维命令-QOS
运维能力
故障隔离能力： 就现阶段技术而言，没有中很好的方式进行可以进行接口（http和rpc）的故障降级与隔离方式。导致服务中一个接口（http和rpc）发生故障后可能传播到整个服务甚至整个系统中。 服务隔离能力： 对于整个系统来说部分业务在docker外，部分服务在docker内时就很难进行处理。一套体系最好在一个注册中心中进行服务组册与发现工作。做服务隔离就非常困难。多注册中心 指标监控能力： 指标监控对于线上业务服务来说是不可或缺的内容。但是对于Dubbo来说支持的比较弱。只有几个点完成这个，所以有些鸡肋的感觉。 服务检测能力： 每个线上服务都需要不断的检测服务的状态，接口响应情况等。对于使用dubbo或heissian方法的检测几乎不太可能。 总结 # RPC是微服务中的一部分，但不是全部。所以，对于作者来说Dubbo是用来处理需要RPC的问题时很好的解决方案。但对于微服务实现来说RPC还是有一些欠缺。
对于以上的问题在阿里内部肯定遇到过，而在开源版本中没有找到只能说阿里没有真正的把内部体系化的技术栈开源出来。而阿里能够开源dubbo并开源了很多配套组件的情况下已经为国内的技术发展做出了很大的贡献。不开源的部分肯定有阿里不开源的原因，不要因为你占领了道德高地而不依不饶的让阿里捐献更多。
参考 # Dubbo文档</description></item><item><title>05 MVC与Controller、Service、DAO的关系</title><link>https://guowei1651.github.io/architecture/15.gossip/05-mvc%E4%B8%8Econtrollerservicedao%E7%9A%84%E5%85%B3%E7%B3%BB/</link><pubDate>Sat, 22 Apr 2023 12:52:56 +0800</pubDate><guid>https://guowei1651.github.io/architecture/15.gossip/05-mvc%E4%B8%8Econtrollerservicedao%E7%9A%84%E5%85%B3%E7%B3%BB/</guid><description>什么是MVC？ 什么是Controller，Service，DAO？</description></item><item><title>06 个人、团队、组织怎么用基础设施建立竞争力</title><link>https://guowei1651.github.io/architecture/15.gossip/06-%E4%B8%AA%E4%BA%BA%E5%9B%A2%E9%98%9F%E7%BB%84%E7%BB%87%E6%80%8E%E4%B9%88%E7%94%A8%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E5%BB%BA%E7%AB%8B%E7%AB%9E%E4%BA%89%E5%8A%9B/</link><pubDate>Sat, 22 Apr 2023 12:52:56 +0800</pubDate><guid>https://guowei1651.github.io/architecture/15.gossip/06-%E4%B8%AA%E4%BA%BA%E5%9B%A2%E9%98%9F%E7%BB%84%E7%BB%87%E6%80%8E%E4%B9%88%E7%94%A8%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E5%BB%BA%E7%AB%8B%E7%AB%9E%E4%BA%89%E5%8A%9B/</guid><description>0. 背景 # 现在很多软件企业以盈利为目标，这个是非常好并可以激活很多竞争力。但将盈利架到每个人员身上这就是不明智。
在很多时候团队、组织内部会陷入缺乏竞争力，动力的情况。在这种情况下怎样激活合理的内部竞争，就是很好的方法。不过在中国遇到这种事情最有可能的是转向权斗。因为在中国不提倡技术创新、技术思考，在内部人员未得到技术好提升好处时就会转向不做事专做人。
1. 基础设施的盈利能力 # 一个简单的例子，为什么阿里做了云基础设施？如果真的思考过这个问题就会知道阿里是怎么用基础设施盈利的。
提高
2. 没有基础设施的组织是人力外包 # 外包
3. 基础设施包括什么 # 管理过程，技术科研能力，业务能力
4. 解决办法 # 激活内驱力</description></item><item><title>07 数据中台在说什么？</title><link>https://guowei1651.github.io/architecture/15.gossip/07-%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%8F%B0%E5%9C%A8%E8%AF%B4%E4%BB%80%E4%B9%88/</link><pubDate>Sat, 22 Apr 2023 12:52:56 +0800</pubDate><guid>https://guowei1651.github.io/architecture/15.gossip/07-%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%8F%B0%E5%9C%A8%E8%AF%B4%E4%BB%80%E4%B9%88/</guid><description>https://www.cnblogs.com/yixinjishu/p/10936384.html</description></item></channel></rss>