<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>14 学习总结 on</title><link>https://doks.netlify.app/architecture/14.summarize/</link><description>Recent content in 14 学习总结 on</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Sat, 22 Apr 2023 12:52:56 +0800</lastBuildDate><atom:link href="https://doks.netlify.app/architecture/14.summarize/index.xml" rel="self" type="application/rss+xml"/><item><title>01 【翻译】软件架构指南</title><link>https://doks.netlify.app/architecture/14.summarize/01-%E7%BF%BB%E8%AF%91%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E6%8C%87%E5%8D%97/</link><pubDate>Sat, 22 Apr 2023 12:52:56 +0800</pubDate><guid>https://doks.netlify.app/architecture/14.summarize/01-%E7%BF%BB%E8%AF%91%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E6%8C%87%E5%8D%97/</guid><description>本指南是[martinfowler.com]上关于软件架构的材料指南。原文地址为：https://martinfowler.com/architecture/。
当软件行业的人们谈论“架构”时，他们指的是一个模糊定义的概念，即软件系统内部设计的最重要方面。一个好的架构是很重要的，否则在将来添加新功能会变得更慢、更昂贵。
和软件界的许多人一样，我一直对“架构”这个词保持警惕，因为它常常暗示着与编程的分离和一种不健康的浮夸。但我通过强调良好的架构是支持其自身发展的，并且与编程紧密结合的东西来解决这个问题。我的大部分职业生涯都围绕着什么样的架构是好架构的问题，并团队如何创建它，以及如何以最好的形式培养我们的组织中的架构思维。本页概述了我对软件架构的看法，并为您指出了有关本网站架构的更多资料。
什么是架构？ # 软件界的人们一直在争论架构的定义。对某些人来说，这就像是一个系统的基本组织，或者是最高级别的组件连接在一起的方式。我的想法是通过与拉尔夫·约翰逊（Ralph Johnson）的邮件交流形成的，他质疑这一措辞，认为没有客观的方法来定义什么是基本的，或者是高层的？好的架构是专家对系统设计的共同理解。 第二种常见的架构定义风格是，它是“需要在项目早期做出的设计决策”，但拉尔夫也对此表示不满，他说，这更像是你希望能够在项目早期做出正确的决策。
他的结论是“架构是最重要的东西。不管那是什么”。乍一看，这听起来很老套，但我发现它有很多丰富的内容。这意味着从架构层面思考决定软件的核心什么（即什么是架构），然后花费精力保持这些架构元素处于良好的状态。为了让开发人员成为架构师，他们需要能够认识到哪些元素是重要的，认识到如果不加以控制，哪些元素可能导致严重的问题。
什么是架构问题？ # 对于软件产品的客户和用户来说，架构是一个棘手的话题，因为它不是他们能马上察觉到的东西。但是一个糟糕的架构是导致软件粗糙元素增长的主要原因，这些元素阻碍了开发人员理解软件。包含软件粗糙元素的系统是很难修改，并导致特性交付速度更慢，缺陷也更多。
这种情况与我们通常的经验相反。我们习惯了“高质量”的东西，认为它更贵。对于软件的某些方面，高质量符合这个标准，比如用户体验。但当涉及到架构和其他内部质量方面时，这种关系是相反的。高的内部质量导致新功能的更快交付，因为没有太多的障碍。
诚然，我们可以在短期内为更快的交付速度牺牲质量，但在粗糙元素的建立产生影响之前，人们低估了粗糙元素导致整体交付速度放缓的速度。虽然这不能客观地衡量，但有经验的开发人员认为，对内部质量的关注在几周内而不是几个月内就见效了。
应用架构 # 软件开发中的重要决策随着我们所考虑的上下文的规模而变化。但有一个共同的尺度是应用程序的尺度，因此是“应用程序架构”。
定义应用程序架构的第一个问题是没有明确定义应用程序是什么。我认为应用程序是一种社会结构：
被开发人员视为单个单元的代码体 业务客户视为单个单元的一组功能 那些有钱的人把这看作是一个单一的预算 这样一个松散的定义会导致应用程序有许多潜在的大小，从开发团队中的几个人到几百人不等。（你会注意到，我将规模视为所涉及的人员数量，我认为这是衡量这类事情的最有用的方法。）这与企业架构的关键区别在于，在社会建设方面存在着很大程度的统一目标。
应用程序边界 # 软件开发中一个尚未决定的问题是决定一个软件的边界是什么。（浏览器是否是操作系统的一部分？）许多面向服务架构的支持者认为应用程序正在消失，因此未来的企业软件开发将是由服务组装在一起形成的。
我不认为应用程序会因为同样的原因而消失，为什么应用程序边界如此难以划定。基本上应用是社会结构：
By Martin Fowler 2003/09/11
微服务指南 # 微服务架构模式是一种将单个应用程序开发为一组小型服务的方法，每个服务都在其自己的进程中运行，并与轻量级机制（通常是http资源api）通信。这些服务是围绕业务能力构建的，可以通过完全自动化的部署机制进行独立部署。对这些服务的集中管理是最低限度的，这些服务可以用不同的编程语言编写，并使用不同的数据存储技术。虽然它们的优势使它们在过去几年中非常流行，但它们带来的代价是增加分布计算、削弱一致性和要求运维成熟。 By Martin Fowler
无服务器（Serverless）架构 # 无服务器架构是结合第三方“后端即服务”（baas）服务和/或包括在“功能即服务”（faas）平台上的托管、临时容器中运行的自定义代码的应用程序设计。通过使用这些思想和相关的思想（如单页面应用程序），这样的体系结构消除了对传统的始终在服务器上的组件的大量需求。无服务器架构可以从显著降低的运营成本、复杂性和工程交付周期中获益，但代价是对供应商依赖性的增加和相对不成熟的支持服务。 By Mike Roberts 2018/05/22
微型前端 # 开发一个好前端非常困难。使许多团队能够同时处理大型复杂的产品更是难上加难。在这篇文章中，我们将描述一个最近的趋势，即将前端整体分解成许多更小、更易于管理的部分，以及这种架构如何提高前端代码开发团队的效率和效率。除了讨论各种好处和成本外，我们还将介绍一些可用的实现选项，并深入讨论演示该技术的完整示例应用程序。 BY Cam Jackson 2019/06/19
GUI架构 # 在2000年代中期我正在从事一些写作项目，这些项目本可以变成书但还没有成功。一个是关于用户界面的体系结构。作为这项工作的一部分，我起草了一份关于gui架构如何发展的描述，将表单和控件的默认方法和模型-视图-控制器（model-view-controller，mvc）模式进行了比较。mvc是软件世界中最难理解的模式之一，可以理解，因为它没有很好的文档记录。因此，我在这里的写作试图更好地描述mvc的真正含义，以及它是如何通过model-view-presenter和其他形式演变的。
Presentation Domain Data Layering # 模块化一个信息丰富的程序最常用的方法之一是将它分为三个广泛的层：表示（ui）、域逻辑（aka business logic）和数据访问。因此，您经常会看到web应用程序被划分为了解如何处理http请求和呈现html的web层、包含验证和计算的业务逻辑层以及排序如何管理数据库或远程服务中的持久数据的数据访问层。
BY Martin Fowler 2015/08/26
企业架构 # 当应用程序架构集中于某种形式的概念应用程序边界内的架构时，企业架构看起来是跨大型企业的架构。这样一个组织通常规模太大，无法将其所有软件分组为任何形式的内聚分组，因此需要跨具有许多代码库的团队进行协调，这些代码库是在相互隔离的情况下开发的，资金和用户是相互独立的。
企业架构的大部分内容都是关于理解什么值得进行集中协调，以及这种协调应该采取什么形式。一个极端是一个中心架构组，它必须批准企业中每个软件系统的所有架构决策。这样的群体会减慢决策速度，无法真正理解如此广泛的系统组合中的问题，从而导致决策失误。但另一个极端是完全没有协调，导致团队重复努力，不同系统无法相互操作，团队之间缺乏技能开发和交叉学习。
像大多数思维敏捷的人一样，我更喜欢在分权方面犯错误，所以我更愿意接近混乱的岩石，而不是令人窒息的控制。但是，站在渠道的那一边仍然意味着我们必须避免触礁，并以一种能够最大限度地降低实际成本的方式来实现本地决策的最大化。</description></item><item><title>02 恰如气氛的软件架构</title><link>https://doks.netlify.app/architecture/14.summarize/02-%E6%81%B0%E5%A6%82%E6%B0%94%E6%B0%9B%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84/</link><pubDate>Sat, 22 Apr 2023 12:52:56 +0800</pubDate><guid>https://doks.netlify.app/architecture/14.summarize/02-%E6%81%B0%E5%A6%82%E6%B0%94%E6%B0%9B%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84/</guid><description>第一章 概述 # 1.1 分治、只是与抽象 # 为了解决软件的复杂度以及规模增长带来的问题，开发者需要精良的武器。这些武器可以分为：分治、知识、抽象。开发者把问题分割为规模更小且易于处理的若干子问题，这样他们就可以运行相似问题的知识来解决某些子问题，而且使用抽象有助于他们进行推理和判断。 分治、知识、抽象的有效性在于他们能帮助我们在不变的治理条件下解决不断增长的问题。 分治是解决复杂度及规模问题的有效策略。 知识是利用学习到的知识、将要学到的知识以及学习学习的知识来解决问题。 抽象是抽取出关键因素，撇去干扰因素。提炼一类事物的本质的方法。 1.5 架构师构建架构 # 把架构当做一种工程制品对待，即架构是可以被分析、理解及设计的产物只有这样，才能偶见更好的系统。 1.8 关于本书 # 软件架构就好似系统的估价，它将影响系统的质量属性与功能呈正交关系，并通过约束来影响系统属性。 风险驱动模型的核心思想极为简单：识别风险，为风险排定优先级；选择和运用相关技术；评估风险降低的程度。</description></item><item><title>03 【翻译】分布式系统模式</title><link>https://doks.netlify.app/architecture/14.summarize/03-%E7%BF%BB%E8%AF%91%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A8%A1%E5%BC%8F/</link><pubDate>Sat, 22 Apr 2023 12:52:56 +0800</pubDate><guid>https://doks.netlify.app/architecture/14.summarize/03-%E7%BF%BB%E8%AF%91%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A8%A1%E5%BC%8F/</guid><description>本文是martinfowler.com上关于分布式系统模式的文章。原文地址为：Patterns of Distributed Systems。如有侵权请联系我。
分布式系统给软件带来了很多挑战。分布式系统通常要求我们有多个数据副本，这些副本需要保持同步。然而，我们不能依赖处理节点可以稳定的工作，也不能依赖网络可靠不会因为延迟导致不一致。尽管如此，还是有很多组织仍然依赖一些列的分布式软件来管理数据存储、消息传递、系统管理和计算能力。这些系统面临的共同问题，他们需要使用类似的解决办法。本文将这些解决方案视为模式并加以开发，通过这些模式，我们可以了解如何更好地理解、交流和教授分布式系统设计。
Unmesh Joshi 是ThoughtWorks的首席顾问。他是一个软件体系结构爱好者，他认为理解分布式系统的原理与过去十年中理解web体系结构或面向对象编程一样重要。 目录 # 这是怎么回事 分布式系统——一种实现视角 模式 问题及其反复出现的解决办法。 进程崩溃 网络延迟 进程暂停 非同步时钟和顺序事件 把它们放在一起-一个分布式系统的例子 实现共识的模式序列 下一步行动 模式 # 一致核心 生成时钟 心跳 高水位线 领导者和追随者 低水位线 法定人数 请求管道 分段测井 单插座通道 单一更新队列 国家观察 有时限租约 提前写入日志 这是怎么回事 # 在过去的几个月里，我一直在ThoughtWorks举办关于分布式系统的研讨会。在举办研讨会时所面临的主要挑战之一是如何将分布式系统的理论映射到Kafka或Cassandra等开源代码库，同时保持讨论的通用性，以涵盖广泛的解决方案。提供了一个不错的模式概念。
模式就其本质而言，允许我们专注于一个特定的问题，使我们非常清楚为什么需要一个特定的解决方案。然后，解决方案描述允许我们给出一个代码结构，它足够具体，可以显示实际的解决方案，但通用性足以涵盖广泛的变化。模式技术还允许我们将各种模式连接在一起，以构建一个完整的系统。这为讨论分布式系统实现提供了一个很好的词汇表。
下面是主流开源分布式系统中观察到的第一组模式。我希望这些模式对所有开发人员都有用。
分布式系统——一种实现视角 # 今天的企业架构充满了自然分布的平台和框架。我们可以看到目前典型企业架构中使用的框架和平台的示例列表，它将如下所示：
平台或框架 例子 数据库 Cassandra, HBase, Riak 消息中间件 Kafka, Pulsar 基础设施 Kubernetes, Mesos, Zookeeper, etcd, Consul 内存数据库/计算网格 Hazelcast, Pivotal Gemfire 有状态微服务 Akka Actors, Axon 文件系统 HDFS, Ceph 模式 克里斯托弗·亚历山大（Christopher Alexander）提出的模式（Patterns）概念。在软件社区中被广泛接受，模式是记录用于构建软件系统的通用设计。模式提供了一种结构化的方式来查看问题空间，而解决方案可以多次看到并经过验证。使用模式的一种有趣方式是能够以模式序列或模式语言的形式将多个模式链接在一起，这为实现“整个”或完整的系统提供了一些指导。将分布式系统视为一系列模式是一种获得深入了解其实现的有用方法。</description></item><item><title>04 【翻译】请求管道</title><link>https://doks.netlify.app/architecture/14.summarize/04-%E7%BF%BB%E8%AF%91%E8%AF%B7%E6%B1%82%E7%AE%A1%E9%81%93/</link><pubDate>Sat, 22 Apr 2023 12:52:56 +0800</pubDate><guid>https://doks.netlify.app/architecture/14.summarize/04-%E7%BF%BB%E8%AF%91%E8%AF%B7%E6%B1%82%E7%AE%A1%E9%81%93/</guid><description>本文是martinfowler.com上关于分布式系统模式的文章。原文地址为：Request Pipeline。如有侵权请联系我。
通过在连接上发送多个请求而不等待前一个请求的响应来提高延迟比。
2020年8月20日
问题 # 如果请求需要等待前一个请求返回的响应，那么使用单个套接字通道在群集中的服务器之间通信可能会导致性能问题。为了获得更好的吞吐量和延迟，服务器上的请求队列应该足够满，以确保服务器容量得到充分利用。例如，当在一个服务器中使用单个更新队列时，它总是可以接受更多的请求，直到队列填满为止，而它正在处理一个请求。如果一次只发送一个请求，则大部分服务器容量都会被不必要地浪费。
解决方案 # 节点向其他节点发送请求，而不等待以前请求的响应。这是通过创建两个独立的线程来实现的，一个用于通过网络通道发送请求，另一个用于接收来自网络通道的响应。
发送方节点通过套接字通道发送请求，而不等待响应。
class SingleSocketChannel… public void sendOneWay(RequestOrResponse request) throws IOException { var dataStream = new DataOutputStream(socketOutputStream); byte[] messageBytes = serialize(request); dataStream.writeInt(messageBytes.length); dataStream.write(messageBytes); } 启动一个单独的线程来读取响应。
class ResponseThread… class ResponseThread extends Thread implements Logging { private volatile boolean isRunning = false; private SingleSocketChannel socketChannel; public ResponseThread(SingleSocketChannel socketChannel) { this.socketChannel = socketChannel; } @Override public void run() { try { isRunning = true; logger.info(&amp;quot;Starting responder thread = &amp;quot; + isRunning); while (isRunning) { doWork(); } } catch (IOException e) { getLogger().</description></item><item><title>05 【翻译】如何系统学习软件设计和架构</title><link>https://doks.netlify.app/architecture/14.summarize/05-%E7%BF%BB%E8%AF%91%E5%A6%82%E4%BD%95%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%92%8C%E6%9E%B6%E6%9E%84/</link><pubDate>Sat, 22 Apr 2023 12:52:56 +0800</pubDate><guid>https://doks.netlify.app/architecture/14.summarize/05-%E7%BF%BB%E8%AF%91%E5%A6%82%E4%BD%95%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%92%8C%E6%9E%B6%E6%9E%84/</guid><description>本文是khalilstemmler.com上关于如何系统学习软件设计和架构的文章。原文地址为：How to Learn Software Design and Architecture | The Full-stack Software Design &amp;amp; Architecture Map。如有侵权请联系我。
因第一次翻译这个作者的文章，并对作者也不甚了解。所以简单的将作者介绍一下。作者：khalil stemmler，在github上查到他人在加拿大，在Apollo GraphQL工作。
从这片文章翻译过程中，遇到一些问题。发现作者的思维比较跳跃，上下文的跳跃性比较强。所以翻译和阅读有一些麻烦。并文中所涉及到的内容皆为作者原意，翻译的意见可能与本文有出入。
软件设计
在计算领域，软件设计和体系结构是计算机所特有的研究领域，比如DevOps或UX设计。这里有张图描述了从Clean Code到微内核中的软件设计和架构。
架构 软件设计 路线图
本主题摘自Solid Book的《w/TypeScript + Node.js的软件架构和设计手册》。如果有兴趣可以查看。
想到Facebook曾经是某人电脑上的一个空白代码文件，而现在正是这家庞大的公司几乎涉足了所有的行业，并影响了全球15.9亿人，这让我觉得很疯狂。
作为一个自学成才的初级开发人员，甚至是中级开发人员，要想继续成长，真正学会如何设计Clean和可伸缩的系统。这个成长路线图似乎有些令人望而生畏。
对我们很多人来说项目会坚持不过一两次迭代，其中一部分原因是因为代码变成了无法维护的混乱。
那么我们从哪里开始学习如何改进我们的设计呢？
事实是：
软件设计和体系结构是一个巨大的课题。
了解如何：
设计一个系统来满足用户的需求 编写易于更改的代码 编写易于维护的代码 编写易于测试的代码 &amp;hellip; 很难。所需的学习的知识实在太大了。
尽管你知道如何编写代码使事情至少运行起来，但更大的挑战是如何编写代码，使其易于修改，以满足当前的需求。
但是，从哪里开始呢？
每当我面对一个复杂的问题时，我都会使用第一原则。
第一原则 # 第一原则是解决问题最有效的方法。
它的工作原理是将一个问题分解到原子级，原子级是我们无法分解，然后从我们确信是真实问题出发重新构造一个解决方案。
因此，让我们首先说明目标，将其应用于软件。
软件的主要目标是什么？
软件的目标是不断地生产满足其用户需求的东西，同时尽可能减少所需的努力。
这是在我很长一段时间以来一直在努力想出的最好的定义，我准备和你争论为什么我认为这是准确的。
不能满足用户需求的软件根本就不是好软件。
而且由于用户的需求经常变化，所以确保软件的设计是为了能够被改变而设计的，这一点很重要。
如果软件不能（容易地）被修改，那它就成了糟糕的软件，因为它阻止了我们满足用户当前的需求。
我们已经确定设计很重要，接下来学习如何制作设计良好的软件就变成很重要的，但这可能是一条漫长的道路。
在本文中，我想向您介绍我认为是软件设计和体系结构的具体支柱。
学习堆栈 # 在我给你看学习路径之前，让我先给你看一下学习堆栈。
与OSI模型类似，每一层都建立在前一层的基础之上。
在堆栈中，我已经在该层中包含了一些最重要概念的示例，但不是全部（因为太多了）。
现在开始看地图。虽然我认为堆栈可以看到更大的图片，但地图更详细一点，因此，我认为它更有用。
图 # 为了避免占用带宽，我降低了网站上显示的地图的质量。如果你想得到一个高质量的png，你可以在我的GitHub上找到。
下面是软件设计和架构图。
阶段1：Clean code # 创建有韧性的软件，第一步就是找出如何编写Clean code。</description></item><item><title>06 【翻译】处理遗留系统替换的模式</title><link>https://doks.netlify.app/architecture/14.summarize/06-%E7%BF%BB%E8%AF%91%E5%A4%84%E7%90%86%E9%81%97%E7%95%99%E7%B3%BB%E7%BB%9F%E6%9B%BF%E6%8D%A2%E7%9A%84%E6%A8%A1%E5%BC%8F/</link><pubDate>Sat, 22 Apr 2023 12:52:56 +0800</pubDate><guid>https://doks.netlify.app/architecture/14.summarize/06-%E7%BF%BB%E8%AF%91%E5%A4%84%E7%90%86%E9%81%97%E7%95%99%E7%B3%BB%E7%BB%9F%E6%9B%BF%E6%8D%A2%E7%9A%84%E6%A8%A1%E5%BC%8F/</guid><description>本文是martinfowler上关于真对遗留系统的处理的文章。原文地址为：Patterns of Legacy Displacement。如有侵权请联系我。
对遗留软件系统进行有效现代化 # 当面临更换现有软件系统的需求时，团队经常会陷入半完成状态的循环中。根据我们的经验我们可以使一系列的模式来打破这种循环，这依赖于：有意识地了解替换遗留软件的预期结果，以逐步交付部分的方式打破并替换遗留系统，并改变组织文化有意识的传播世间不变的只有变化。
目录 # 遗留系统替代过程中的死循环 打破循环 了解您想要的结果 降低变更成本 改进业务流程 淘汰旧系统 即将中断 较新的技术 决定如何将问题分解成更小的部分 入门 成功交付零件 改变组织以允许这种情况持续发生 示例：集成中间件移除 了解结果 分解问题：第一个接缝和重构 成功交付零件：构建功能，维护合同 成功交付零件（续）：过渡到实时服务 - 使用第二个接缝 改变组织以允许这种情况持续发生 结束语 本系列具体模式 # 提取产品线 功能对等 侧边栏 # 我们想像 Netflix 一样 事件风暴 - 现代流程映射的瑞士军刀 最难的转变是范式转变 延伸阅读： # 企业架构 演进式设计
在过去几十年的时间里，我们经常在帮助大型组织处理他们的遗留系统。在这样做的过程中，我们学到了很多关于什么是有效的方法，并看到了许多导致失败的过程。我们决定在工作中留出一些时间，用我们看到的、使用过的各种方法以模式的形式记录下我们学到的东西。
本文充当这些模式的概览。我们经常看到在组织在半途而废的更换遗留系统的跑步机上奔跑。我们认为打破这个循环的关键是需要按顺序完成三项活动，并在公司的生命周期中反复进行。我们使用这些方式作为描述遗留系统替换模式的主要结构。
我们一直相信，有效的软件开发需要逐步发布有价值的功能，写作也是如此—— 尤其是在网络时代。我们从这篇叙述性文章开始，随着我们写下它们的详细信息，将逐渐添加模式，以及展示它们如何组合的其他示例。我们不能保证系列文章的完成时间，因为我们的首要任务是客户工作，这里有很多需要替换的遗留系统。如果您有兴趣了解这项工作的更多部分，它们将在Martin的twitter和本网站的RSS上公布。
遗留系统替代过程中的死循环 # 和我们合作的许多组织，都多次尝试删除遗留系统。在一个相当典型的案例中，他们经历了长达3-5年的一系列现代化计划。每次他们都会定义一种新的技术方法，然后添加到大型多年现代化计划并朝着这个目标努力。
在每个项目中客户会在的某个时候遇到了一个危机点，不断变化的业务需求将超过他们当前的技术战略。这时的第一种情况是触发他们将软件从头再开始，他们会对程序采取瀑布式“大爆炸”的方式设计与实现。这意味着放弃了先前大部分的工作。而第二种情况是采用增量交付方式，采取这种方法的更多的只是在已经很复杂的环境之上添加一层稍微较新的技术。对于这两种情况，他们都无法停用任何遗留系统的堆积，成本节约和风险降低的关键业务目标仍未实现，这对于许多遗留替换工作来说是非常普遍的结果。
他们屡次失败有几个关键因素：
首先，看到他们糟糕结果在很大程度上是组织不合理的产物；特别是它的领导力、组织结构和工作方式。他们认为只要选择更新的技术，而其他一切都保持不变，他们会得到与过去不同的结果。事后看来，这显然是不现实的。
其次，通过一个大型变革计划来实现现代化，计划本身又包括一系列项目和团队。这些项目被视为与任何现有项目（BUA，一切照旧，Business As-Usual）工作无关。因此，BAU继续根据现有系统交付业务需求，而新项目团队则根据替换计划开始时的内容进行新的开发。 随着时间的推移，他们发现企业实际需要的东西与替换计划开始时的需求之间的差距越来越大。项目运行的时间越长，项目计划、BAU、未来需求三者之间的差距就越大。虽然变更控制流程已向计划添加新要求，但这些流程非常耗时。而且由于前期与项目实施方的合同变更造成成本高得令人望而却步。
再次，希望与现有系统的业务流程集实现功能对等。一开始这些尝试是承诺以某种方式在幕后“改进”技术，为企业提供他们今天所拥有的一切。到后期，业务领导者看到在替换过程中的多次失败并担心替换中断，开始认为这是一种风险较低的策略。这是一项定义对支持的“原样”功能巨大的挑战，它导致了一个“大爆炸”式的大型单一版本切换计划。
我们对这些组织的观察结论是技术最多只占遗留问题的50%，工作方式、组织结构和领导力对成功同样重要。
打破循环 # 显然有必要打破“遗留系统替代计划”的循环。但组织需要能够继续满足业务需求的同时更换过时的技术，而且所有这些都是在富技术和严峻的竞争环境下进行的。
我们发现有一系列方法可以帮助我们应对这些挑战。它们将问题分解为更小的部分，以便在改进技术的同时满足新要求。从广义上讲，它们分为四类：
了解您想要达到的结果 决定如何将问题分解成更小的部分，并成功交付零部件 改变组织以允许这种情况持续发生 了解您想要达到的结果 # 对于一个组织来说，在处理遗留问题时就他们想要实现的结果达成一致至关重要。虽然这似乎很明显，但组织的不同部分往往对预期结果有截然不同的看法。大多数遗留系统现代化的过程涉及我们下面列出的几个结果，但在开始替换之前确定哪些是优先事项是至关重要的。</description></item><item><title>07 【翻译】Gossip传播</title><link>https://doks.netlify.app/architecture/14.summarize/07-%E7%BF%BB%E8%AF%91gossip%E4%BC%A0%E6%92%AD/</link><pubDate>Sat, 22 Apr 2023 12:52:56 +0800</pubDate><guid>https://doks.netlify.app/architecture/14.summarize/07-%E7%BF%BB%E8%AF%91gossip%E4%BC%A0%E6%92%AD/</guid><description>本文是martinfowler上关于分布式系统模式中的一篇文章。原文地址为：Gossip Dissemination。如有侵权请联系我。</description></item><item><title>08 【翻译】SaaS-IaaS-PaaS-aPaaS-HpaPaaS之间有什么区别？</title><link>https://doks.netlify.app/architecture/14.summarize/08-%E7%BF%BB%E8%AF%91saas-iaas-paas-apaas-hpapaas%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/</link><pubDate>Sat, 22 Apr 2023 12:52:56 +0800</pubDate><guid>https://doks.netlify.app/architecture/14.summarize/08-%E7%BF%BB%E8%AF%91saas-iaas-paas-apaas-hpapaas%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/</guid><description>原文是What’s the difference between SaaS / IaaS / PaaS / aPaaS / HpaPaaS?
2019年9月16日 鲍比·兰卡斯特
过去20年中，互联网服务的增长引入了一组新的缩写词，用于描述不同的解决方案，如SaaS / IaaS / PaaS / aPaaS / HpaPaaS之类的缩写词。这些首字母缩写词可能会有些混乱，因此我们将分解它们之间的区别，以便您找到适合您的解决方案。
SaaS（软件即服务） # 在互联网的早期，只有简单的网站和服务，并且没有通过互联网交付的完整应用程序。随着Internet的诞生，诸如Amazon和eBay之类的应用程序提供商诞生了一种新的软件类别，该软件可以通过Internet交付给用户。无需使用SaaS应用程序在自己的服务器上安装昂贵的软件，您无需任何设置即可在Internet上访问它们。像Salesforce这样的早期SaaS提供商开始按月收取使用该服务的费用，这使公司可以以更可预测的价格便宜得多地购买软件。如今，大多数公司在每个部门使用SaaS应用程序，而今天大多数软件都是通过按月/按年订阅购买的。SaaS模型使部署软件应用程序变得更容易，更便宜，并且催生了现代云革命。
IaaS（基础架构即服务） # 在90年代后期，同时出现了一种新型的“即服务”技术模型，即IaaS（基础设施即服务）模型。Amazon Web Services是该领域的先驱者之一，他们在构建公司可以利用的基础架构服务方面发挥了领导作用。在此之前，公司必须管理自己的服务器和数据中心，这不仅成本高昂，而且需要大量技术资源。像AWS这样的IaaS提供商允许公司通过互联网即服务对其进行管理，从而完全摆脱服务器。IaaS提供商无需购买昂贵的硬件和服务器，从而从根本上降低了托管，部署和运行应用程序的价格。
（IaaS解决方案专注于通过互联网交付基础架构即服务，而SaaS解决方案专注于通过互联网交付应用即服务）
相关：解释了10个低码行业术语
PaaS（平台即服务） # 随着时间的推移，出现了第三种“即服务”产品，即平台即服务产品。基础架构即服务（IaaS）解决方案开始提供围绕软件开发而不仅仅是基础架构管理服务的越来越多的功能。诸如Heroku之类的平台构建在诸如AWS之类的IaaS平台之上，为开发人员提供了额外的抽象层，以便于他们轻松部署和运行其代码。 IaaS的重点是增强基础架构工程师的能力，而PaaS的重点在于增强软件开发人员的能力。这些PaaS产品允许开发人员以最少的基础架构工作来部署，运行和管理其代码，从而使他们可以更快地构建软件。随着时间的流逝，IaaS平台开始向堆栈上方移动，以提供越来越多的PaaS功能。现在，像AWS一样，大多数IaaS平台都提供了广泛的PaaS解决方案，使软件开发和部署变得更加容易。
aPaaS（应用程序平台即服务） # 上面的PaaS来自IaaS解决方案，该解决方案提供了从基础结构控件到开发平台控件的更多堆栈功能。从IaaS到PaaS的同时，SaaS平台也同步发展了越来越多的平台功能，这催生了aPaaS（应用程序平台即服务）。SaaS应用程序（如Salesforce）开始向下移动，并提供了更多的软件开发功能，以便用户可以自定义和构建SaaS应用程序。这些aPaaS平台对希望构建应用而无需学习编码的新一代“公民开发人员”特别有用。如今，许多SaaS应用程序都提供了软件开发功能，可将其移至aPaaS领域。因此，PaaS和aPaaS在某些方面非常相似，因为它们都致力于为Web应用程序提供软件开发服务。通过查看PaaS和aPaaS的起源，您可以了解它们的区别。 PaaS解决方案是从提供更多堆栈功能的IaaS解决方案发展而来的。 aPaaS解决方案是从提供更多向下堆栈功能的SaaS解决方案发展而来的。
（PaaS是从提供更多上层功能的IaaS解决方案演变而来的，而aPaaS解决方案是从提供更多下层功能的SaaS解决方案演变而来。）
另请阅读： 低代码与定制软件：有什么区别？
HpaPaaS（高生产力应用程序平台即服务） # 这使我们成为加入“即服务”行列的最新缩写：HpaPaaS（高效能应用平台即服务）解决方案。 HpaPaaS解决方案是对应用程序平台即服务解决方案的进一步发展，但高度关注速度和开发人员的生产力。诸如Kintone之类的HpaPaaS解决方案提供了软件开发解决方案，可帮助开发人员快速构建Web应用程序而无需编写代码。随着公司开始授权“公民开发人员”构建应用程序，他们开始寻找使这些公民开发人员可以有效构建的应用程序数量最大化的方法。诸如Kintone之类的HpaPaaS解决方案使公民开发人员能够迅速将其想法转化为可运行的应用程序。
（与标准的aPaaS解决方案相比，HpaPaaS解决方案在混合中增加了额外的要素，速度，并提供了更快的软件开发功能。）
最后，这是我想分享的有趣推文。
用培根解释on-prem，IaaS，PaaS和SaaS [图像源未知，不是我&amp;hellip;] 如果您知道其他任何首字母缩写词，并希望查看我们的解释，请在下面评论！
不要忘记查看Gartner发布的有关HpaPaaS解决方案的最新报告。立即免费下载Gartner 2019企业低代码应用平台魔力象限报告的副本。
关于作者 鲍比·兰卡斯特 Bobby是Kintone的产品和合作伙伴营销专家。</description></item><item><title>09 Low-Code-aPaas实施过程</title><link>https://doks.netlify.app/architecture/14.summarize/09-low-code-apaas%E5%AE%9E%E6%96%BD%E8%BF%87%E7%A8%8B/</link><pubDate>Sat, 22 Apr 2023 12:52:56 +0800</pubDate><guid>https://doks.netlify.app/architecture/14.summarize/09-low-code-apaas%E5%AE%9E%E6%96%BD%E8%BF%87%E7%A8%8B/</guid><description>背景 # 客制化为什么是必须的？ # 客制化要做什么？ # 业界怎么做客制化？ # https://docs.apicloud.com/ 国外的OutSystems、Mendix，国内的明道云、氚云，明道云
我们怎么做客制化？ # 总结 # 参考 # 什么品类适合千人千面？ 提供个性化？不如提供定制化！ 揭秘个性化定制的真相 SaaS软件定制化服务已成为企业发展刚需！ SaaS成熟度模型的4个等级 低代码平台：10分钟从入门到原理 3个小时，从学到做，我用低代码平台搭了一套管理系统</description></item></channel></rss>