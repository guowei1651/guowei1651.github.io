<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>03 工作 on</title><link>https://guowei1651.github.io/essay/03.worker/</link><description>Recent content in 03 工作 on</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Sat, 22 Apr 2023 12:52:56 +0800</lastBuildDate><atom:link href="https://guowei1651.github.io/essay/03.worker/index.xml" rel="self" type="application/rss+xml"/><item><title>代码为什么越写越乱？</title><link>https://guowei1651.github.io/essay/03.worker/%E5%8E%9F%E5%88%9B%E4%BB%A3%E7%A0%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%B6%8A%E5%86%99%E8%B6%8A%E4%B9%B1/</link><pubDate>Sat, 22 Apr 2023 12:52:56 +0800</pubDate><guid>https://guowei1651.github.io/essay/03.worker/%E5%8E%9F%E5%88%9B%E4%BB%A3%E7%A0%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%B6%8A%E5%86%99%E8%B6%8A%E4%B9%B1/</guid><description>1. 问题域定义 # 这个问题往大的说是业务治理问题，往小了说是代码分拆。 我的建议是自顶向下的思考，自顶向下的思考方式一方面全局的看一个问题，能给出一个问题最优解，另一方面因为只有这样才有成长，才能在下次遇到类似问题时解决问题。
考虑清楚为什么会形成超大的类？ 可以通过哪些方法对业务进行拆分，以达到拆分的效果？ 拆分完成之后怎么判断拆分的是否合理？ 2. 问题分析 # 2.1 怎么形成的超大类 # 刚开始编写这个文件的时候，我相信作者肯定是已经想过了这个类要负责什么，哪些业务应该在这个类中，这个类与上下游的关系是什么样的。但是最初在第一次业务变更时有一点不太应该在本类中加进来的业务代码，但跟本类有这强联系的代码就直接加。之后总有类似的事情发生，总有不是强相关，但又有关系的代码加入进来。导致代码随着业务不断地变化与调整，而逐渐的陷入混乱。
所以，不必担心业务代码不会增长，它的增长是不受控制的。就像物理学中的熵增定律一样，在一个封闭系统中，如果没有外部做功，它就会逐渐陷入混乱。
2.2 用什么进行业务治理？ # 业务代码的增长，随后陷入混乱是必然的，这件事是不是让人感到这个问题就无解了。因为不管改多少遍都会陷入混乱，在一个无法解决的问题上人们总是会感觉到无力，从而丧失解决从根本上解决问题的力量。
不要使用上帝类，在DDD中有上帝类的概念。上帝类就是在一个类中解决所有的问题，可以看到MVC模式中的Service就是上帝类的完美代表。所以，不要只用一种模式解决所有的问题。这里给出的都是思考的过程以及方式来解决问题。所以可能会感觉到泛泛之谈。
这里主要思想是DDD，但是经过了一些变形：明确服务边界，定义服务内容，阐述服务关系。具体到代码拆分上：
**从业务上划分包**：包中的业务是对于特定的业务实体的操作。 **定义包的边界**：包中的实体发生变化，应该以事件的方式通知其他关心的业务。而不是由本包解决所有的外部问题 **明确包与包之间的关系**：包中只负责本包该处理的业务，不负责其他业务实体的业务。例如：在下单之后，应该以事件的方式通知仓库，支付，物流等等去做该做的事情。而不是自己去做。 2.3 判断拆分的是否合理？ # 最简单的规则就是单一职责，拆分后的内容是否符合单一职责。然后就是扩展到SOLID规则。
3. 解决域展示 # 实际解决过也是一个不断演化的过程，接受代码会随着时间不断的变化才会接受这种解决方式。
第一阶段：facade模式 # 将facade类作为能力透出类，而拆分出的实际工作类作为业务功能类。例如：策略部署其实可以分为策略定义和策略的使用，就可以使用facade类向外暴露接口能力，然后策略定义一个类，测录使用一个类。
第二阶段：划分领域对象 # 进一步就是就是将拆分出的两个实现类再拆分为：工具类，服务类，外部事件处理类，领域事件类。从名字就可以知道它这些类的意义。
4. 总结 # 业务治理是长期工作，需要理解问题产生的原因才可以真正的解决问题。</description></item><item><title>代码为什么越写越乱？2</title><link>https://guowei1651.github.io/essay/03.worker/%E4%BB%A3%E7%A0%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%B6%8A%E6%9D%A5%E8%B6%8A%E4%B9%B1/</link><pubDate>Sat, 22 Apr 2023 12:52:56 +0800</pubDate><guid>https://guowei1651.github.io/essay/03.worker/%E4%BB%A3%E7%A0%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%B6%8A%E6%9D%A5%E8%B6%8A%E4%B9%B1/</guid><description>1. 问题域定义 # 这个问题往大的说是业务治理问题，往小了说是代码分拆。 我的建议是自顶向下的思考，自顶向下的思考方式一方面全局的看一个问题，能给出一个问题最优解，另一方面因为只有这样才有成长，才能在下次遇到类似问题时解决问题。
考虑清楚为什么会形成超大的类？ 可以通过哪些方法对业务进行拆分，以达到拆分的效果？ 拆分完成之后怎么判断拆分的是否合理？ 2. 问题分析 # 2.1 怎么形成的超大类 # 刚开始编写这个文件的时候，我相信作者肯定是已经想过了这个类要负责什么，哪些业务应该在这个类中，这个类与上下游的关系是什么样的。但是最初在第一次业务变更时有一点不太应该在本类中加进来的业务代码，但跟本类有这强联系的代码就直接加。之后总有类似的事情发生，总有不是强相关，但又有关系的代码加入进来。导致代码随着业务不断地变化与调整，而逐渐的陷入混乱。
所以，不必担心业务代码不会增长，它的增长是不受控制的。就像物理学中的熵增定律一样，在一个封闭系统中，如果没有外部做功，它就会逐渐陷入混乱。
2.2 用什么进行业务治理？ # 业务代码的增长，随后陷入混乱是必然的，这件事是不是让人感到这个问题就无解了。因为不管改多少遍都会陷入混乱，在一个无法解决的问题上人们总是会感觉到无力，从而丧失解决从根本上解决问题的力量。
不要使用上帝类，在DDD中有上帝类的概念。上帝类就是在一个类中解决所有的问题，可以看到MVC模式中的Service就是上帝类的完美代表。所以，不要只用一种模式解决所有的问题。这里给出的都是思考的过程以及方式来解决问题。所以可能会感觉到泛泛之谈。
这里主要思想是DDD，但是经过了一些变形：明确服务边界，定义服务内容，阐述服务关系。具体到代码拆分上：
从业务上划分包：包中的业务是对于特定的业务实体的操作。 定义包的边界：包中的实体发生变化，应该以事件的方式通知其他关心的业务。而不是由本包解决所有的外部问题 明确包与包之间的关系：包中只负责本包该处理的业务，不负责其他业务实体的业务。例如：在下单之后，应该以事件的方式通知仓库，支付，物流等等去做该做的事情。而不是自己去做。 2.3 判断拆分的是否合理？ # 最简单的规则就是单一职责，拆分后的内容是否符合单一职责。然后就是扩展到SOLID规则。
3. 解决域展示 # 实际解决过也是一个不断演化的过程，接受代码会随着时间不断的变化才会接受这种解决方式。
第一阶段：facade模式 # 将facade类作为能力透出类，而拆分出的实际工作类作为业务功能类。例如：策略部署其实可以分为策略定义和策略的使用，就可以使用facade类向外暴露接口能力，然后策略定义一个类，测录使用一个类。
第二阶段：划分领域对象 # 进一步就是就是将拆分出的两个实现类再拆分为：工具类，服务类，外部事件处理类，领域事件类。从名字就可以知道它这些类的意义。
4. 总结 # 业务治理是长期工作，需要理解问题产生的原因才可以真正的解决问题。</description></item><item><title>方便定制化的企业系统</title><link>https://guowei1651.github.io/essay/03.worker/%E6%96%B9%E4%BE%BF%E5%AE%9A%E5%88%B6%E5%8C%96%E7%9A%84%E4%BC%81%E4%B8%9A%E7%B3%BB%E7%BB%9F/</link><pubDate>Sat, 22 Apr 2023 12:52:56 +0800</pubDate><guid>https://guowei1651.github.io/essay/03.worker/%E6%96%B9%E4%BE%BF%E5%AE%9A%E5%88%B6%E5%8C%96%E7%9A%84%E4%BC%81%E4%B8%9A%E7%B3%BB%E7%BB%9F/</guid><description>Odoo 是一系列开源商业应用程序套装，此套装可满足贵公司的一切应用需求，例如，企业基本的进销存、采购、销售、MRP生产制造、品保质量保障、企业招聘、员工合同、休假、午餐管理、内部论坛、车队管理、内部聊天IM沟通、客诉追溯管理、CRM客户关系管理、VOIP、E-Shop电子商务、网店、企业官方网站，财务会计、银行对账、资产管理、HR工资管理、预算管理、WMS仓库库存管理、POS街边小摊、社区商店、项目管理、条码、PLM等等等。</description></item><item><title>关于Solaris中类似于的Inotify功能</title><link>https://guowei1651.github.io/essay/03.worker/%E5%85%B3%E4%BA%8Esolaris%E4%B8%AD%E7%B1%BB%E4%BC%BC%E4%BA%8E%E7%9A%84inotify%E5%8A%9F%E8%83%BD/</link><pubDate>Sat, 22 Apr 2023 12:52:56 +0800</pubDate><guid>https://guowei1651.github.io/essay/03.worker/%E5%85%B3%E4%BA%8Esolaris%E4%B8%AD%E7%B1%BB%E4%BC%BC%E4%BA%8E%E7%9A%84inotify%E5%8A%9F%E8%83%BD/</guid><description>背景 # 当年的巨无霸一去不复返了啊。在SUN收购Mysql之后，我们还在讨论SUN已经是一个全产业链的超级大公司了。那时的SUN有语言JAVA，有操作系统Solaris，有数据库Mysql，有IDE，有硬件。
原文： # 可以使用http://blogs.sun.com/praks/entry/file_events_notification中介绍的port方法，在用户态监视系统中某个文件(大家都知道*nix中的文件，并不一定真的是文件，可以是目录等等一些东西)。该机制可以监控的事件有：
Watchable events:
FILE_ACCESS /* Monitored file/directory was accessed */ FILE_MODIFIED /* Monitored file/directory was modified */ FILE_ATTRIB /* Monitored file/directory's ATTRIB was changed */ FILE_NOFOLLOW /* flag to indicate not to follow symbolic links */ Exception events - cannot be filtered:
FILE_DELETE /* Monitored file/directory was deleted */ FILE_RENAME_TO /* Monitored file/directory was renamed */ FILE_RENAME_FROM /* Monitored file/directory was renamed */ UNMOUNTED /* Monitored file system got unmounted */ MOUNTEDOVER /* Monitored file/directory was mounted on */ 这些事件类型定义在sys/port.</description></item><item><title>三年经验的C需要懂的问题</title><link>https://guowei1651.github.io/essay/03.worker/%E4%B8%89%E5%B9%B4%E7%BB%8F%E9%AA%8C%E7%9A%84c%E9%9C%80%E8%A6%81%E6%87%82%E7%9A%84%E9%97%AE%E9%A2%98/</link><pubDate>Sat, 22 Apr 2023 12:52:56 +0800</pubDate><guid>https://guowei1651.github.io/essay/03.worker/%E4%B8%89%E5%B9%B4%E7%BB%8F%E9%AA%8C%E7%9A%84c%E9%9C%80%E8%A6%81%E6%87%82%E7%9A%84%E9%97%AE%E9%A2%98/</guid><description>前言： # 2013年3月写的文章。那会的工作主要是做一些通信设备上的底层软件，所以会深入的了解C的相关底层内容。这是那时候写的三年的C经验需要知道的事情。请不要问我这些问题的答案。
正文： # double free是什么问题？申请地址与释放地址不一致会有什么问题？ main函数最多有几个参数？各是什么作用？ crt是什么？编译器是怎么样连接crt的（描述cl或者gcc方式） c语言程序的入口函数是哪个？（绝对不是main） 请描述不使用main函数的情况先怎样设置程序入口函数？（描述cl或gcc中的一种） C++调用C函数时为什么要将C函数包含在extern “C”中？ABI是什么？ 赋值运算符与位与运算符哪个优先级高？ offset是怎样实现的？ float型的数据怎么判断它是否等于0？ 怎样声明函数可以写以下代码 fun()[0](); 如果有两个结构体要相互引用指针，应该怎么定义这两个结构体？ 比较两个值是否相等时为什么要把常量写在前面？ 请写出两种防止头文件重复引用的方法？ extren时变量类型与定义是变量类型不一致会有什么问题？ 例如： file1.c char array[512] = { 0 }; file2.c extern char *array ; 以下程序的输出结果是： int i = 0； int j = sizeof(i++); printf(&amp;quot;i = %d j = %d\n&amp;quot;, i, j); 请写一段可以反应volatile关键字作用的代码。 代码中还会对n进行加加吗？ fun() { int n = 0； 。。。。。。 return n++; } 请解释C语言中最终要的两点： 符号的连接性与作用域； 变量的存储性与声明周期。 函数的可重入性是什么样的概念？</description></item><item><title>商业Java微服务开发平台观点</title><link>https://guowei1651.github.io/essay/03.worker/%E5%95%86%E4%B8%9Ajava%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0%E8%A7%82%E7%82%B9/</link><pubDate>Sat, 22 Apr 2023 12:52:56 +0800</pubDate><guid>https://guowei1651.github.io/essay/03.worker/%E5%95%86%E4%B8%9Ajava%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0%E8%A7%82%E7%82%B9/</guid><description>最近一段时间陆续接触到很多关于《商业Java微服务开发平台》的东西。所以想简单的说说关于这个方面的东西。先说说这些平台的作用，这些所谓的平台就是将现有的Spring框架，前端框架再次封装一下。使其变的更可用、更易用。有的在开发框架的基础上补充了一些关于DevOps的内容。
这些“商业Java微服务开发平台”最主要的目标是快速构建开发平台，并提供快速开发能力。
典型的“商业Java微服务开发平台” # 人人开源： https://www.renren.io/
BladeX https://bladex.vip/#/
Pig https://pig4cloud.com/
NDP:Nebulogy DevPlatform http://www.nebulogy.com/NDP.html
restcloud http://www.restcloud.cn/
观点 # 我相信写这些所谓快速开发平台的人根本不是有大公司背景的，没有经过很好的逻辑思维训练的人编写出来的。因为商业系统肯定是处于闭源的状态。所以这些快速开发平台所能提供的能力，提供能力的封装都是有问题的。这些内容只能说暂时可用，长久使用必定给公司，项目，产品带来很大的弊端。
会采用这些快速开发平台的人是一种不负责任的作为。这些平台对于公司妨碍公司技术能力积累，阻碍公司内部学习型组织的建立过程。对公司的非功能性需求把控能力大幅降低。
再说行业内部为什么会出现这样的平台，因为行业内的软件研发能力过于低下。很容易被一些封装忽悠，并对新技术的学习能力过于低下。现在有很多很好的技术可以快速解决很多问题，而这些技术被大多数人视而不见。等到技术流行的时候被推着前行的，就像之前的PHP。</description></item></channel></rss>