<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>03 工作 on</title><link>https://guowei1651.github.io/essay/03.worker/</link><description>Recent content in 03 工作 on</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Sat, 22 Apr 2023 12:52:56 +0800</lastBuildDate><atom:link href="https://guowei1651.github.io/essay/03.worker/index.xml" rel="self" type="application/rss+xml"/><item><title>python学习</title><link>https://guowei1651.github.io/essay/03.worker/01-python%E5%AD%A6%E4%B9%A0/</link><pubDate>Sat, 22 Apr 2023 12:52:56 +0800</pubDate><guid>https://guowei1651.github.io/essay/03.worker/01-python%E5%AD%A6%E4%B9%A0/</guid><description>技术是用来解决问题的。要了解了技术之后才能真正的知道解决了什么样的问题。学习python过程中遇到了这样那样的问题，下面的python学习图是展示python各个方向的内容以及进度。 python学习其实比较麻烦，因为很多东西没有系统性的介绍。没有中文文档等都阻碍了我们对python的热情。</description></item><item><title>Scrum工作完成准则(Definition-of-Done，DoD)</title><link>https://guowei1651.github.io/essay/03.worker/04-scrum%E5%B7%A5%E4%BD%9C%E5%AE%8C%E6%88%90%E5%87%86%E5%88%99definition-of-donedod/</link><pubDate>Sat, 22 Apr 2023 12:52:56 +0800</pubDate><guid>https://guowei1651.github.io/essay/03.worker/04-scrum%E5%B7%A5%E4%BD%9C%E5%AE%8C%E6%88%90%E5%87%86%E5%88%99definition-of-donedod/</guid><description>前因 # 在软件研发过程中，有很多事项需要与团队达成一致。需要与团队中的所有人同步产品规划、业务蓝图、技术规范、技术蓝图等等内容。这样为团队在长期上制定目标之后、团队内部再自行制定短期目标时就会更加贴近我们的最终目标。从而形成公司文化氛围，提高公司的整体运行效率。
在软件研发过程中为了解决软件的复杂度，领域驱动设计（DDD）为我们提供了《统一语言（UBIQUITOUS LANGUAGE）》解决产品、项目中客户、运营、研发中思路，方向不一致的问题。在架构设计与架构演进过程中，正如《PPT架构师与写代码这件事儿》所描述的，团队人员对技术的理解也是不一致的。
综上，在软件研发过程中可能会遇到各种各样的认识不一致，思想不一致，方向不一致的问题。我们接下里说明在团队技术实现过程中的不一致问题。
意义 # 在软件研发团队中对于一项工作怎样算完成其实是没有完全定义的。在一些比较有经验的成员手中只需要说明一次既可以完成整体工作，在一些新手手中可能需要多次的说明，多次反复之后才能完成一项工作。再推广到团队，由组织合理，配合默契的团队完成一件复杂任务和组织不合理或配合不默契的团队完成复杂任务是需要更多的时间或者损失质量的。
并且在软件研发团队中人员的更替是在所难免的。人员变更给团队带来了不确定性，团队的完成任务的能力，团队完成任务的质量，团队的理解任务的方式等都会发生变化。所以，怎样保证保证任务的正常进展？成为一个比较重要的问题。
业界也有借鉴其他行业的很多经验，有很多方法将这些问题的成本降低到最低。例如：量化，Checklist，PDCA等等。我们这里说明软件研发的CheckList。
使用敏捷Scrum中的DoD概念，推广到软件研发中的各个过程中得到这里的完成准则。完成准则是为一项重复性事项创建的CheckList。在做某一项事项时需要检查列表中的内容，已确定是否真正的完成了工作。这里以代码提交的完成准则作为最简单介绍。
制作完成准则 # 完成准则最主要的目标是解决团队中遇到的问题。所以，制作完成准则需要注意的是需要团队所有成员参与。需要团队内所有成员的认同之后才能真正的推行。
具体步骤： 第一步：完成准则需要根据团队的问题，针对这些问题需要做问题调查。可以采用不记名投票的方式将所有的问题全部采集到一起。 第二步：针对这些已经采集到的问题，讨论是否有可以落地的解决办法，这些解决办法必须是可以操作与检测的。 第三步：按照重要性与优先级将解决办法排序到完成准则中。 第四步：申明《完成准则》是团队红线，这里已经达成对《完成准则》的认识，制定违反《完成准则》的惩罚。
以下为完成准则例子：
具体跟进 # 需要执行《完成准则》的惩罚，这样才可以让团队成员真正的认为完整准则的重要性。以及思想统一的认识。
参考： # Definition Of Done Techniques for using the Definition of Done (DoD) Definition of Ready (DoR) vs. Definition of Done (DoD)</description></item><item><title>Spring-Boot链接Elasticsearch-7-3</title><link>https://guowei1651.github.io/essay/03.worker/02-spring-boot%E9%93%BE%E6%8E%A5elasticsearch-7-3/</link><pubDate>Sat, 22 Apr 2023 12:52:56 +0800</pubDate><guid>https://guowei1651.github.io/essay/03.worker/02-spring-boot%E9%93%BE%E6%8E%A5elasticsearch-7-3/</guid><description>背景 # 在服务发展到一定阶段后，需要进行用户数据分析。在调研与设计用户行为分析系统的过程中需要从日志服务器Elasticsearch中解析用户行为日志。然后用日志记录用户的行为。在这个过程中发现对接Elasticsearch 7.3还是有一定的困难，所以记录下来并共享出来，为之后如果有遇到问题提供一种思路。
过程 # 使用Spring Boot最新代码以及spring-boot-starter-data-elasticsearch进行Elasticsearch的对接工作。在对接过程中一直在报：找不到可用的ES节点。所以，在调查中发现很多版本对应不上造成的问题。例如：使用Srping Boot的2.1.9.RELEASE版本，引入的spring-boot-starter-data-elasticsearch所附带的3.1.11.RELEASE的spring-data-elasticsearch包，而这个包应该是可以支持7.x的版本的。如下图所示：
但是2.1.9的spring boot就是不能使用。使用的Spring Data Elasticsearch是3.1.11版本的，对于3.1.11这个版本支持到Elasticsearch协议的6.2.2的版本。而使用Elasticsearch 7.3的，支持的最低接口版本是6.8.0，所以，在2.1.19是不能对接Elasticsearch 7.3的。
查看原因应该是因为使用Elasticsearch Clients的6.8版本中有集群客户端（PreBuiltTransportClient）的调用，而在后续的版本中已经要删除这种方式了。所以，使用PreBuiltTransportClient就会造成问题。所以，升级Srping Boot到2.2.0版本应该不会有结果。不过还是升级到2.2.0试试。测试后是可以使用的。
结论 # $\color{red}{如果需要使用Spring Boot链接Elasticsearch 7.3请使用2.2.0以上版本的Srping Boot}$。
参考 # Spring Data Elasticsearch - Reference Documentation Spring Data for Elasticsearch Doc Elasticsearch Clients</description></item><item><title>代码为什么越写越乱？</title><link>https://guowei1651.github.io/essay/03.worker/%E5%8E%9F%E5%88%9B%E4%BB%A3%E7%A0%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%B6%8A%E5%86%99%E8%B6%8A%E4%B9%B1/</link><pubDate>Sat, 22 Apr 2023 12:52:56 +0800</pubDate><guid>https://guowei1651.github.io/essay/03.worker/%E5%8E%9F%E5%88%9B%E4%BB%A3%E7%A0%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%B6%8A%E5%86%99%E8%B6%8A%E4%B9%B1/</guid><description>1. 问题域定义 # 这个问题往大的说是业务治理问题，往小了说是代码分拆。 我的建议是自顶向下的思考，自顶向下的思考方式一方面全局的看一个问题，能给出一个问题最优解，另一方面因为只有这样才有成长，才能在下次遇到类似问题时解决问题。
考虑清楚为什么会形成超大的类？ 可以通过哪些方法对业务进行拆分，以达到拆分的效果？ 拆分完成之后怎么判断拆分的是否合理？ 2. 问题分析 # 2.1 怎么形成的超大类 # 刚开始编写这个文件的时候，我相信作者肯定是已经想过了这个类要负责什么，哪些业务应该在这个类中，这个类与上下游的关系是什么样的。但是最初在第一次业务变更时有一点不太应该在本类中加进来的业务代码，但跟本类有这强联系的代码就直接加。之后总有类似的事情发生，总有不是强相关，但又有关系的代码加入进来。导致代码随着业务不断地变化与调整，而逐渐的陷入混乱。
所以，不必担心业务代码不会增长，它的增长是不受控制的。就像物理学中的熵增定律一样，在一个封闭系统中，如果没有外部做功，它就会逐渐陷入混乱。
2.2 用什么进行业务治理？ # 业务代码的增长，随后陷入混乱是必然的，这件事是不是让人感到这个问题就无解了。因为不管改多少遍都会陷入混乱，在一个无法解决的问题上人们总是会感觉到无力，从而丧失解决从根本上解决问题的力量。
不要使用上帝类，在DDD中有上帝类的概念。上帝类就是在一个类中解决所有的问题，可以看到MVC模式中的Service就是上帝类的完美代表。所以，不要只用一种模式解决所有的问题。这里给出的都是思考的过程以及方式来解决问题。所以可能会感觉到泛泛之谈。
这里主要思想是DDD，但是经过了一些变形：明确服务边界，定义服务内容，阐述服务关系。具体到代码拆分上：
**从业务上划分包**：包中的业务是对于特定的业务实体的操作。 **定义包的边界**：包中的实体发生变化，应该以事件的方式通知其他关心的业务。而不是由本包解决所有的外部问题 **明确包与包之间的关系**：包中只负责本包该处理的业务，不负责其他业务实体的业务。例如：在下单之后，应该以事件的方式通知仓库，支付，物流等等去做该做的事情。而不是自己去做。 2.3 判断拆分的是否合理？ # 最简单的规则就是单一职责，拆分后的内容是否符合单一职责。然后就是扩展到SOLID规则。
3. 解决域展示 # 实际解决过也是一个不断演化的过程，接受代码会随着时间不断的变化才会接受这种解决方式。
第一阶段：facade模式 # 将facade类作为能力透出类，而拆分出的实际工作类作为业务功能类。例如：策略部署其实可以分为策略定义和策略的使用，就可以使用facade类向外暴露接口能力，然后策略定义一个类，测录使用一个类。
第二阶段：划分领域对象 # 进一步就是就是将拆分出的两个实现类再拆分为：工具类，服务类，外部事件处理类，领域事件类。从名字就可以知道它这些类的意义。
4. 总结 # 业务治理是长期工作，需要理解问题产生的原因才可以真正的解决问题。</description></item><item><title>方便定制化的企业系统</title><link>https://guowei1651.github.io/essay/03.worker/%E6%96%B9%E4%BE%BF%E5%AE%9A%E5%88%B6%E5%8C%96%E7%9A%84%E4%BC%81%E4%B8%9A%E7%B3%BB%E7%BB%9F/</link><pubDate>Sat, 22 Apr 2023 12:52:56 +0800</pubDate><guid>https://guowei1651.github.io/essay/03.worker/%E6%96%B9%E4%BE%BF%E5%AE%9A%E5%88%B6%E5%8C%96%E7%9A%84%E4%BC%81%E4%B8%9A%E7%B3%BB%E7%BB%9F/</guid><description>Odoo 是一系列开源商业应用程序套装，此套装可满足贵公司的一切应用需求，例如，企业基本的进销存、采购、销售、MRP生产制造、品保质量保障、企业招聘、员工合同、休假、午餐管理、内部论坛、车队管理、内部聊天IM沟通、客诉追溯管理、CRM客户关系管理、VOIP、E-Shop电子商务、网店、企业官方网站，财务会计、银行对账、资产管理、HR工资管理、预算管理、WMS仓库库存管理、POS街边小摊、社区商店、项目管理、条码、PLM等等等。</description></item><item><title>关于Solaris中类似于的Inotify功能</title><link>https://guowei1651.github.io/essay/03.worker/%E5%85%B3%E4%BA%8Esolaris%E4%B8%AD%E7%B1%BB%E4%BC%BC%E4%BA%8E%E7%9A%84inotify%E5%8A%9F%E8%83%BD/</link><pubDate>Sat, 22 Apr 2023 12:52:56 +0800</pubDate><guid>https://guowei1651.github.io/essay/03.worker/%E5%85%B3%E4%BA%8Esolaris%E4%B8%AD%E7%B1%BB%E4%BC%BC%E4%BA%8E%E7%9A%84inotify%E5%8A%9F%E8%83%BD/</guid><description>背景 # 当年的巨无霸一去不复返了啊。在SUN收购Mysql之后，我们还在讨论SUN已经是一个全产业链的超级大公司了。那时的SUN有语言JAVA，有操作系统Solaris，有数据库Mysql，有IDE，有硬件。
原文： # 可以使用http://blogs.sun.com/praks/entry/file_events_notification中介绍的port方法，在用户态监视系统中某个文件(大家都知道*nix中的文件，并不一定真的是文件，可以是目录等等一些东西)。该机制可以监控的事件有：
Watchable events:
FILE_ACCESS /* Monitored file/directory was accessed */ FILE_MODIFIED /* Monitored file/directory was modified */ FILE_ATTRIB /* Monitored file/directory's ATTRIB was changed */ FILE_NOFOLLOW /* flag to indicate not to follow symbolic links */ Exception events - cannot be filtered:
FILE_DELETE /* Monitored file/directory was deleted */ FILE_RENAME_TO /* Monitored file/directory was renamed */ FILE_RENAME_FROM /* Monitored file/directory was renamed */ UNMOUNTED /* Monitored file system got unmounted */ MOUNTEDOVER /* Monitored file/directory was mounted on */ 这些事件类型定义在sys/port.</description></item><item><title>年轻人们远离华为吧</title><link>https://guowei1651.github.io/essay/03.worker/05-%E5%B9%B4%E8%BD%BB%E4%BA%BA%E4%BB%AC%E8%BF%9C%E7%A6%BB%E5%8D%8E%E4%B8%BA%E5%90%A7/</link><pubDate>Sat, 22 Apr 2023 12:52:56 +0800</pubDate><guid>https://guowei1651.github.io/essay/03.worker/05-%E5%B9%B4%E8%BD%BB%E4%BA%BA%E4%BB%AC%E8%BF%9C%E7%A6%BB%E5%8D%8E%E4%B8%BA%E5%90%A7/</guid><description>最近接触了华为的一些人，简单的分析一下华为。这里需要跟深入的分析，所以这里只是简单的陈述一下，后面补上深入分析。
严谨与谨慎 # 之所以为什么华为没有互联网基因，在互联网行业中干不过其他公司？就是因为严谨与谨慎。而为什么在设备制造（通信设备，消费电子设备）领域可以有一席之地？都是因为严谨与谨慎。
严谨与谨慎从软件层面上可以导出一个结果：设计需要完备，实施需要完善，过程需要全控，故障需要全部预先考虑。这其实是一种非常好的工匠精神，专业精进的态度。但是这条配合上下面的群狼战术就可能就有问题了。
而对于从事互联网行业的工作来说，最提倡的是：适度。何为适度？即与现在的发展相匹配的设计、实施、过程、故障管控即可。
群狼战术 # 华为引以为豪的群狼战术，其表达的思想是通过多人合作、团队合作的方式去战胜精英主义的思路。现在很多“互联网+”行业中最重要的问题就在于合作都没有形成。所以，在这里应该鼓励非互联网头部公司应该学习合作方式。而现在大厂比较推崇的方式在：组织中台。
从另外一种说法来说，群狼是需要相互依赖，相互确认。团队运行久了就会衍生出相互推诿、繁杂协调的过程。这样就需要很强的公司文化的支撑，怎样在提倡合作的团队内形成竞争。这样在团队中稍微走偏就可能形成很难收拾的结果。而群狼战术在华为为什么运行起来了，是因为有它自己的其他文化支撑的。而支撑这些文化的可能是隐性的，很难察觉到，很难表述的。
群狼战术隐藏的内容我分析两点：1. 平庸化，2.成本高昂。从个人的角度来看，平庸化意味着创新缺失，由上到下的制定战略制定到执行，有大家一起去达成某个目标。从某种角度来说，这个很大程度基于人口红利。现在对于行业内成本高昂的群狼战术，产生的原因在人员投入和过程协调。
绩效考核 # 群狼战术之后人员的贡献、人员能力基本上都拉平了。那在拉平的团队情况下，怎么做绩效考核？那是不是就变成了轮值主席？轮值排C？从现在的角度看就已经是这样的内容了。 为了提高绩效团队中每一个人都主动去完成份外工作，负责更多的内容。实质化的内卷就来了。最终为了绩效，又不能从创新角度团队解决现在的问题。那就是内卷。</description></item><item><title>三年经验的C需要懂的问题</title><link>https://guowei1651.github.io/essay/03.worker/%E4%B8%89%E5%B9%B4%E7%BB%8F%E9%AA%8C%E7%9A%84c%E9%9C%80%E8%A6%81%E6%87%82%E7%9A%84%E9%97%AE%E9%A2%98/</link><pubDate>Sat, 22 Apr 2023 12:52:56 +0800</pubDate><guid>https://guowei1651.github.io/essay/03.worker/%E4%B8%89%E5%B9%B4%E7%BB%8F%E9%AA%8C%E7%9A%84c%E9%9C%80%E8%A6%81%E6%87%82%E7%9A%84%E9%97%AE%E9%A2%98/</guid><description>前言： # 2013年3月写的文章。那会的工作主要是做一些通信设备上的底层软件，所以会深入的了解C的相关底层内容。这是那时候写的三年的C经验需要知道的事情。请不要问我这些问题的答案。
正文： # double free是什么问题？申请地址与释放地址不一致会有什么问题？ main函数最多有几个参数？各是什么作用？ crt是什么？编译器是怎么样连接crt的（描述cl或者gcc方式） c语言程序的入口函数是哪个？（绝对不是main） 请描述不使用main函数的情况先怎样设置程序入口函数？（描述cl或gcc中的一种） C++调用C函数时为什么要将C函数包含在extern “C”中？ABI是什么？ 赋值运算符与位与运算符哪个优先级高？ offset是怎样实现的？ float型的数据怎么判断它是否等于0？ 怎样声明函数可以写以下代码 fun()[0](); 如果有两个结构体要相互引用指针，应该怎么定义这两个结构体？ 比较两个值是否相等时为什么要把常量写在前面？ 请写出两种防止头文件重复引用的方法？ extren时变量类型与定义是变量类型不一致会有什么问题？ 例如： file1.c char array[512] = { 0 }; file2.c extern char *array ; 以下程序的输出结果是： int i = 0； int j = sizeof(i++); printf(&amp;quot;i = %d j = %d\n&amp;quot;, i, j); 请写一段可以反应volatile关键字作用的代码。 代码中还会对n进行加加吗？ fun() { int n = 0； 。。。。。。 return n++; } 请解释C语言中最终要的两点： 符号的连接性与作用域； 变量的存储性与声明周期。 函数的可重入性是什么样的概念？</description></item><item><title>商业Java微服务开发平台观点</title><link>https://guowei1651.github.io/essay/03.worker/%E5%95%86%E4%B8%9Ajava%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0%E8%A7%82%E7%82%B9/</link><pubDate>Sat, 22 Apr 2023 12:52:56 +0800</pubDate><guid>https://guowei1651.github.io/essay/03.worker/%E5%95%86%E4%B8%9Ajava%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0%E8%A7%82%E7%82%B9/</guid><description>最近一段时间陆续接触到很多关于《商业Java微服务开发平台》的东西。所以想简单的说说关于这个方面的东西。先说说这些平台的作用，这些所谓的平台就是将现有的Spring框架，前端框架再次封装一下。使其变的更可用、更易用。有的在开发框架的基础上补充了一些关于DevOps的内容。
这些“商业Java微服务开发平台”最主要的目标是快速构建开发平台，并提供快速开发能力。
典型的“商业Java微服务开发平台” # 人人开源： https://www.renren.io/
BladeX https://bladex.vip/#/
Pig https://pig4cloud.com/
NDP:Nebulogy DevPlatform http://www.nebulogy.com/NDP.html
restcloud http://www.restcloud.cn/
观点 # 我相信写这些所谓快速开发平台的人根本不是有大公司背景的，没有经过很好的逻辑思维训练的人编写出来的。因为商业系统肯定是处于闭源的状态。所以这些快速开发平台所能提供的能力，提供能力的封装都是有问题的。这些内容只能说暂时可用，长久使用必定给公司，项目，产品带来很大的弊端。
会采用这些快速开发平台的人是一种不负责任的作为。这些平台对于公司妨碍公司技术能力积累，阻碍公司内部学习型组织的建立过程。对公司的非功能性需求把控能力大幅降低。
再说行业内部为什么会出现这样的平台，因为行业内的软件研发能力过于低下。很容易被一些封装忽悠，并对新技术的学习能力过于低下。现在有很多很好的技术可以快速解决很多问题，而这些技术被大多数人视而不见。等到技术流行的时候被推着前行的，就像之前的PHP。</description></item><item><title>写好代码并不难</title><link>https://guowei1651.github.io/essay/03.worker/02-%E5%86%99%E5%87%BA%E5%A5%BD%E4%BB%A3%E7%A0%81%E5%B9%B6%E4%B8%8D%E9%9A%BE/</link><pubDate>Sat, 22 Apr 2023 12:52:56 +0800</pubDate><guid>https://guowei1651.github.io/essay/03.worker/02-%E5%86%99%E5%87%BA%E5%A5%BD%E4%BB%A3%E7%A0%81%E5%B9%B6%E4%B8%8D%E9%9A%BE/</guid><description>0. 背景 # 本文主要讨论的内容是代码层面的内容。之前将软件行业的认知分为七个层次，这里主要的内容集中在代码层面，会涉及一些程序、软件层次中的内容。适合与刚入行的同学阅读。为初级工程师快速的成为中级工程师提供一条道路。
本文从几个常见的问题入手开始讨论写代码过程中可能遇到的问题(第一节)，再讨论编写代码中除了常见问题还应该考虑哪些问题(第二节)，讨论完遇到的问题以及要考虑的问题之后开始开始讨论哪些方式可以解决这些问题(第三节)，到最后以实践的角度落地这些解决问题的方法(第四节)。以深入浅出的方式说明写出好代码并不是那么的难。
1. 代码为什么越写越乱？ # 在新写的代码和老代码的改造/重构过程中，总会发现因为技术、业务将一个简单的问题弄的越来越复杂。从而导致代码越来越难看，越来越不能被理解。那么有哪些原因导致代码越来越混乱？
1.1 结构化程序设计的主要特点流程式代码 # 从学习过程来看，任何一个研发人员都是先从面向过程编程开始学习变成的。在学习的过程中一个最主要的过程就是使用顺序的方式将所要实现的内容实现了。
在软件工程中我们学习过软件设计中需要包含模块/组件，但是很多软件从业者没有办法将这个概念落地到代码编写过程中。因为没有办法划分模块的边界、确定模块的意义、描述清楚模块间关系，所以就不进行模块的拆分。很多从业者不能理解模块/组件到底应该落在软件认知7层模型中的那一层也是影响开发人员不进行模块划分的原因。
1.1.1 流程化的代码编写方式有问题吗？ # 经常遇到一个文件打天下（上帝类）的情况，例如在mvc下的service是不是上帝类，该做的不该做的都放在这个里面？ 一个Method走天下，还是例如在mvc中一个业务都直接写在service的一个方法中。一个方法一般情况下都在200行以上，这种就很容易形成铁桶一块的问题。根本没有办法修改这个方法，如果要新添功能就直接在方法中加一块代码。
1.2 MVC是万能的？ # 在WEB编程兴起的年代，也伴随着MVC模式的兴起。所以，大家在学习WEB编程时都在学习和使用MVC模式。而MVC的特点是它由Model，View，Controller组成。而在微服务时代View都由前端实现，后端基本不用操心这方面的内容。Controller中主要做转换，控制，安全。那么业务逻辑应该在哪里完成呢？在Model中吗？这就是MVC没有办法解决的问题。
1.2.1 面向对象 # 在MVC中实际实现过程中，Model中由Entity、Service和Dao组成。Entity负责业务实体，Service负责业务处理，Dao负责持久化。而Service中写的代码都是以面向过程的方式进行编写的。所以Service和Model的概念都是冲突的。Model代表的是业务模型，Service根本就没有办法代表业务模型。也没有办法说用Java写的代码就是面向对象的。
1.2.2 代码的边界在哪里？ # 上面说到的一个文件打天下，一个方法打天下是很明显的代码的边界是业务流程。并不用吃惊，因为很多同事嘴上说着做技术，其实写代码的时候都是写的业务流程代码。 这里只想说这种代码边界是错误的。原因有这么几点：
业务流程的公用性比较小，所以导致方法，文件的公用性更小。从而导致代码无法复用。 业务流程没有拆分，无步骤则代码不易读。造成很难维护。 1.2.3 分层关系 # 在MVC的优点中做了一项叫做开闭原则：对扩展开放，对修改关闭。做了不同层次之间的封装，做了一层隔离。
1.3 软件复杂度的三个来源：规模，结构与变化 # 《解构领域驱动设计》中张逸老师说到软件复杂度的来源：规模，结构与变化。这三项最终都会落在代码中，例如业务会不断的发展，不断的增长，所以代码的规模也会不断的增长。稍微上规模一点的业务系统，都会牵扯到各种各样的实体，以及实体之间的关系导致结构的复杂度提升。业务是否会演进，业务演进就会带动代码的变化。
在代码层次中怎么应对这些内容呢？
1.4 总结 # 从结构化变成深入到软件的复杂度，一路上都是各种问题来影响代码的编写过程。考虑每一个方向都有可能和其他方向的代码有质的区别，我们这里并不讨论这几个方向深入之后会产生什么样的代码，我们这里讨论公共的一些好代码的写法。
1.4.1 问题 # 大家都习惯了流程化的代码编写方式，并深受MVC之毒（其实并非MVC问题，而是不深入思考）。在这种前提下又有这么复杂的问题需要编写代码来解决。代码写的烂是不是变成了正常事。
1.4.2 解决问题 # 分治思维 结构化程序设计的主要特点是抛弃 goto 语句，采取“自顶向下、逐步细化、模块化”的指导思想。 结构化程序设计本质上还是一种面向过程的设计思想，但通过“自顶向下、逐步细化、 模块化”的方法，将软件的复杂度控制在一定范围内，从而从整体上降低了软件开发的复杂度。&amp;ndash;李运华《从零开始学架构》
不断的实践设计模式 学会写OO代码，并能够理解KISS，DRY，SOLID，最少知识、向稳定依赖原则。并能够在工作过程中不断的实践这些原则。 下面主要说明落地这两个方向会遇到怎样的问题？以及怎样解决这些问题？
2. 怎么做到高内聚低耦合？ # 现代软件的代码第一目标是可读性，其他的事情可靠，性能，安全等都是可以通过其他的方式解决的。所以，在编写代码的过程中第一要务是让代码能被别人看懂。
如下图随心所欲的做事和有规则的做事，有很大的区别。区别就在于怎么进行分类整理？ 下面逐步深入讨论一下代码怎么做到高内聚低耦合。第一步讨论划分代码模块（函数）时可能遇到的问题，第二部讨论划分模块（函数）时是不是应该考虑所有原则，最后以统一的方式进行解答并引申到下一节的结构化。
2.1 模块/组件的定义 # 在编写代码过程中并不是只写方法（函数）就可以，还需要进行文件划分，Package划分。这些在某种意义上就是不同层次的模块划分。但是划分过程中可能会遇到这段代码应该放在文件A中还是文件B中的问题，这里会从不同的层面列出问题，让大家对这部分有更深入的思考。</description></item></channel></rss>