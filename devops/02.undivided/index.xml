<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>02 未划分 on</title><link>https://guowei1651.github.io/devops/02.undivided/</link><description>Recent content in 02 未划分 on</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Sat, 22 Apr 2023 12:52:56 +0800</lastBuildDate><atom:link href="https://guowei1651.github.io/devops/02.undivided/index.xml" rel="self" type="application/rss+xml"/><item><title>[翻译]功能切换（又称功能标志）</title><link>https://guowei1651.github.io/devops/02.undivided/00-%E7%BF%BB%E8%AF%91%E5%8A%9F%E8%83%BD%E5%88%87%E6%8D%A2%E5%8F%88%E7%A7%B0%E5%8A%9F%E8%83%BD%E6%A0%87%E5%BF%97/</link><pubDate>Sat, 22 Apr 2023 12:52:56 +0800</pubDate><guid>https://guowei1651.github.io/devops/02.undivided/00-%E7%BF%BB%E8%AF%91%E5%8A%9F%E8%83%BD%E5%88%87%E6%8D%A2%E5%8F%88%E7%A7%B0%E5%8A%9F%E8%83%BD%E6%A0%87%E5%BF%97/</guid><description>原文为martin fowler的个人网站中的：Feature Toggles (aka Feature Flags)
功能切换（通常也称为功能标志）是一种强大的技术，允许团队在不更改代码的情况下修改系统行为。功能切换可以分为多种使用类别，在实现和管理功能切换时必须考虑选用适合的类别。功能切换会带来一定的复杂度，对于这种复杂度我们可以通过有效的管理切换配置来控制，也可以通过限制系统中切换的数量以降低复杂度。
作者：
Pete Hodgson Pete Hodgson是ThoughtWorks的顾问，他在过去的几年里帮助团队在可持续交付高质量软件方面变得非常出色。他特别热衷于基于互联网的移动端、Ruby、敏捷、软件的功能性方法和啤酒。 类似的文章有：连续交付，应用架构
“功能切换”是一组模式，可以帮助团队快速而安全地向用户提供新功能。在本文中，我们将从一个短篇故事开始，介绍一些功能切换的典型的场景。然后本文将深入研究细节，介绍功能切换的特定的模式和实践。有了这些模式和实践团队将更加有效的使用功能切换。
功能切换(Feature Toggles)也被称为功能标志(Feature Flags)、功能位(Feature Bits)或功能翻转(Feature Flippers)。这些词都说明的是同一件事。在本文中，我将交替使用功能切换和功能标志。
一个切换的故事 # 想象一下这个场景：你正在参与一个复杂的城市规划模拟游戏的开发工作，这个游戏由几个团队分工开发。你的团队负责核心模拟引擎。您的任务是提高样条网格算法(Spline Reticulation algorithm)的效率。你现在需要花几周的时间对实现进行彻底检查。同时，你的团队中其他成员将需要继续在代码库进行其他部分的开发。
基于以前合并两个长期分支是的痛苦经历你不希望避免为此建立独立的代码分支。并且，为了整体团队的输出你决定整个团队仍将继续在主干分支上工作。同时在做样条网络算法改进的开发人员将使用功能切换来防止他们的工作影响团队的其余部分。
特征标志的诞生 # 这是研究算法的开发人员引入的第一个变化：
之前 function reticulateSplines(){ // current implementation lives here } 这些代码示例都是使用JavaScript ES2015标准。
之后 function reticulateSplines(){ var useNewAlgorithm = false; // useNewAlgorithm = true; // UNCOMMENT IF YOU ARE WORKING ON THE NEW SR ALGORITHM if( useNewAlgorithm ){ return enhancedSplineReticulation(); }else{ return oldFashionedSplineReticulation(); } } function oldFashionedSplineReticulation(){ // current implementation lives here } function enhancedSplineReticulation(){ // TODO: implement better SR algorithm } 开发人员将当前的算法实现转移到一个oldFashionedSplineReticulation函数中，并将reticulateSplines转换为一个切换点(Toggle Point)。现在，如果有人正在研究新算法，他们可以通过使用useNewAlgorithm=true来启用“新算法”。</description></item><item><title>[翻译]面向领域的可观测性</title><link>https://guowei1651.github.io/devops/02.undivided/01-%E7%BF%BB%E8%AF%91%E9%9D%A2%E5%90%91%E9%A2%86%E5%9F%9F%E7%9A%84%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/</link><pubDate>Sat, 22 Apr 2023 12:52:56 +0800</pubDate><guid>https://guowei1651.github.io/devops/02.undivided/01-%E7%BF%BB%E8%AF%91%E9%9D%A2%E5%90%91%E9%A2%86%E5%9F%9F%E7%9A%84%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/</guid><description>原文为martin fowler的个人网站中的：Domain-Oriented Observability
译者序 # 对于一个开发人员来说，应该关注的并不只是实现过程以及实现内容。更应该关注软件运行期的内容。可能是因为现在的开发人员的代码根本活不到软件运行期所以大家都不关注这部分的内容。不过随着国内软件水平的持续提升以及最终用户方对软件运行期要求的提高会逐渐倒逼开发人员开始关注运行期的内容。所以，提前一步进行知识的储备以及学习是非常有必要的。
一般情况下我们所说的指标监控都是在说明技术指标，技术上标识服务的可用性，可靠性的内容。对于一个软件系统来说，技术指标只能部分体现业务的感受。不能全面的体现出业务的情况以及业务发展趋势等内容。对于业务来说没有办法深入了解软系统运行情况。这对于业务决策、业务规划都是大问题，而本文为我们提供一种业务指标监控的方法论，帮助软件系统更好的了解用户感受，为之后的用户感受优化做出指导。
本文的作者依然是之前翻译过的《功能切换（又称功能标志）》的作者**Pete Hodgson**。
正文 # 在我们的软件系统中，可观测性一直都是很有价值的，在这个云和微服务的时代，可观测性变得更加重要。然而，我们添加到系统中的可观察性在本质上往往是相当低的级别和技术性的，而且常常需要向各种日志、工具和分析框架的粗略、冗长的调用乱扔代码库。本文描述了一种清理这种混乱的模式，它允许我们以一种干净的、可测试的方式添加与业务相关的可观察性。
由于当前的趋势，如微服务和云，现代软件系统正变得更加分布式，运行在不太可靠的基础设施上。在我们的系统中建立可观测性一直是必要的，但这些趋势使得它比以往任何时候都更加重要。同时，DevOps运动意味着监控生产的人员比以往任何时候都更有可能在运行的系统中实际添加自定义的检测代码，而不是不得不将可观察性固定在一边。
但是，我们如何将可观测性添加到我们最关心的业务逻辑中，而不让检测细节阻塞我们的代码库呢？而且，如果这个工具很重要，我们如何测试我们是否正确实现了它？在本文中，我将通过将以业务为中心的可观测性视为我们代码库中的一个一流概念，来演示面向领域的可观测性哲学与一种称为领域探测的实现模式的结合是如何提供帮助的。
目录 # 观察什么 # 可观测性问题 # 收拾残局 # 域探测 可观测性测试 # 测试Instrumentation代码是一种痛苦 域探测支持更清晰、更集中的测试 包括执行上下文 元数据类型 注入元数据 # 正在收集检测上下文 域探测的范围 替代实施 # 基于事件的可观测性 面向方面编程 何时应用面向领域的可观测性？ # 重新拟合现有的代码库 观测什么 # “可观察性”的范围很广，从低级技术指标到高级业务关键绩效指标（kpi）。在技术方面，我们可以跟踪诸如内存和CPU利用率、网络和磁盘I/O、线程计数和垃圾收集（GC）暂停等内容。在业务方面，我们的业务/域度量可以跟踪购物车放弃率、会话持续时间或支付失败率等。
因为这些更高级别的指标是特定于每个系统的，所以它们通常需要手动编写的检测逻辑。这与较低级别的技术指标形成了对比，后者更通用，而且通常在启动时除了注入某种监视代理之外，不需要对系统的代码库进行太多修改就可以实现。
还需要注意的是更高级别的、面向产品的度量更具价值，因为根据定义，它们更紧密地反映了系统正在朝着其预期的业务目标运行。
我们可以通过添加跟踪有价值度量的工具实现面向领域的可观测性。
可观测性问题 # 因此，面向领域的可观测性是很有价值的，但它通常需要手工滚动的检测逻辑。这种定制的工具与我们系统的核心域逻辑并驾齐驱，在这里，清晰、可维护的代码至关重要。不幸的是，业务指标插装代码对于领域来说往往是嘈杂的，如果我们不小心，它可能会导致阅读代码时分散注意力，造成领域混乱。
让我们看一个引入检测代码可能导致的混乱的例子。在添加任何可观察性之前，下面是一个假设的电子商务系统（有些天真）折扣代码逻辑：
class ShoppingCart… applyDiscountCode(discountCode){ let discount; try { discount = this.discountService.lookupDiscount(discountCode); } catch (error) { return 0; } const amountDiscounted = discount.</description></item><item><title>服务运行环境</title><link>https://guowei1651.github.io/devops/02.undivided/02-%E6%9C%8D%E5%8A%A1%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83/</link><pubDate>Sat, 22 Apr 2023 12:52:56 +0800</pubDate><guid>https://guowei1651.github.io/devops/02.undivided/02-%E6%9C%8D%E5%8A%A1%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83/</guid><description>概述： # 现阶段服务运行环境有很多种方式，可以从不同的角度划分。比较原始的有直接在硬件的操作系统上运行，稍高级一点的需要在硬件系统上虚拟化操作系统再运行系统服务。还有更高级的是在操作系统上做系统隔离然后再运行，在向上可以使用无服务器架构运行服务。
这里介绍使用Swarm进行服务运行环境搭建，以及使用过程中的一些注意事项。下图为Swarm帮我们解决的问题。 技术选型： # 业界在开发SaaS化服务时，有很多经验可以借鉴。阿里的大中台服务、HeroKu的十二因子、OpenStack的服务群组、NetFlix的地域IDC、微服务的设计规范等等，这些帮我们在不同的层面上制定相关的要求与解决方案。 在这里大概的总结一下，一个网络服务产品服务在运行环境上的一些大概要求。
编号 要求 说明 1 所有地方统一的运行环境 1. 生产环境和开发人员的开发环境时一样的
2. 生产环境和测试环境时一样的
3. 最小运行环境必须可以在开发人员环境上启动并运行 2 可以针对每一个服务进行资源限制 1. 可以根据硬件的情况进行服务的资源的划分
2. 可以根据服务的负载情况限制服务的资源 3 方便的运行态管理 1. 支持日志
2. 支持运行时数据获取
3. 动态的配置数据下发
4. 快速启动与优雅关闭功能需要支持 4 简单的部署，升级管理 1. 需要支持蓝绿发布
2. 需要可以根据部署情况，切换流量到不同的服务商 5 可以适应大范围的扩缩容 1. 可以根据服务的负载情况进行动态的伸缩工作
2. 最好能够自动的伸，手动的缩 6 方便的运行版本，回滚管理 1. 部署过程中或部署完成后发现版本问题，可以方便的回滚
2. 有自己的发行版管理方法，可以选择确定版本运行 7 最好支持服务发现 1. 各种形式的服务发现工作 运行环境的要求的策略是尽量少的操作就可以完成服务的监控与上线操作，并且是越少越好。所以，下面的技术选择过程中也是会按照这个大原则并根据上面的要求进行技术的选择。
运行环境技术近些年发展出来很多种。所以，这里简单的说明一下各种技术的对比。 使用IaaS系统搭建服务需要进行中间件与运行时，数据持久化的控制。用PaaS做会方便很多用，只需要开发上层应用即可，并对上层应用的部署进行管理。用FaaS的话只需要写脚本，讲脚本上传后就可以运行在任何地方。FaaS把底层的所有内容都屏蔽掉了，不需要进行相关的调试。
从某种角度来看FaaS是最好的选择，它可以满足所有的设计原则。可以满足无状态服务，前后端分离，Restful接口，弹性伸缩，异步任务，延时任务，自动恢复等等特点。不过现阶段，没有成熟的IDE可以支持FaaS的开发，所以从某种角度限制了FaaS的发展。这里就可以排除FaaS的技术选择。
这里就剩下IaaS和PaaS的选择，选择这两个可以使用两条原则：1. 如需要最大程度的免除运维操作，可以使用PaaS，2. 比较可控性与费用。如果使用IaaS自行搭建服务比PaaS的可控性和费用要好，那就可以选择IaaS服务。
在不同的项目或产品上对服务的关注点不一样，所以这里需要针对不同的项目进行分析。我这里选择的是IaaS和PaaS中间的一档，我自己搭建一些PaaS提供的服务，使用另外一些PaaS提供的服务。这样组合形成我的服务运行环境。
本文中会使用Swarm搭建的PaaS运行环境。用Docker的环境隔离能力和Swarm的服务调度能力完成运行环境搭建。
环境搭建： # 搭建过程非常简单，可以参照Swarm Mode官方文档进行搭建。</description></item><item><title>配置管理</title><link>https://guowei1651.github.io/devops/02.undivided/03-%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86/</link><pubDate>Sat, 22 Apr 2023 12:52:56 +0800</pubDate><guid>https://guowei1651.github.io/devops/02.undivided/03-%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86/</guid><description>部署和配置管理工具简介 https://riboseyim.gitbook.io/perf/devops-deployment
2018 Docker 用户报告 - Sysdig Edition https://riboseyim.gitbook.io/perf/devops-container-usage</description></item><item><title>上手实践</title><link>https://guowei1651.github.io/devops/02.undivided/04-%E4%B8%8A%E6%89%8B%E5%AE%9E%E8%B7%B5/</link><pubDate>Sat, 22 Apr 2023 12:52:56 +0800</pubDate><guid>https://guowei1651.github.io/devops/02.undivided/04-%E4%B8%8A%E6%89%8B%E5%AE%9E%E8%B7%B5/</guid><description>如何从零开始搭建 CI/CD 流水线</description></item><item><title>设计-部署流水线设计</title><link>https://guowei1651.github.io/devops/02.undivided/05-%E8%AE%BE%E8%AE%A1-%E9%83%A8%E7%BD%B2%E6%B5%81%E6%B0%B4%E7%BA%BF%E8%AE%BE%E8%AE%A1/</link><pubDate>Sat, 22 Apr 2023 12:52:56 +0800</pubDate><guid>https://guowei1651.github.io/devops/02.undivided/05-%E8%AE%BE%E8%AE%A1-%E9%83%A8%E7%BD%B2%E6%B5%81%E6%B0%B4%E7%BA%BF%E8%AE%BE%E8%AE%A1/</guid><description>描述 # 在一个软件产品公司中，一般的基础设施会包括在每个产品线上的各种环境、以及针对这些环境构建起来的部署流水线。
local：本地开发环境 dev：内部开发环境 mock：团队间协作时使用的模拟环境 test：供测试人员测试环境 performance：非功能需求测试环境 stage：试运行环境（新功能部分目标用户使用） production：对外开放的产品环境 一个已经上线的正式产品，第一要务就是保证线上系统是稳定可靠运行的。所以需要通过各种手段保证新功能上线，线上系统问题的快速反馈与立即解决。根据不同公司产品形态的不同，每个公司都需要有一套功能上线流程以保证线上系统的正常运行。 上图中比较详尽的描述了一个功能从开发到上线的整体过程。且在过程中每一个过程都由不同的角色参与。最终保证系统在线上环境的正常运行。故根据上图的流程下面对持续交付过程中操作进行分析。
分析与拆分 # 软件开发是一个团队合作的工作。在图中由相关的人员做相关的推动之后功能才能进入到下一个步骤。每一个步骤都可以将动作分为：构建、部署、测试和发布。而每个步骤所做的内容也有所不同，下面以步骤和环境例举要做哪些操作:
步骤 构建 部署 测试 发布 开发集成 编译
代码扫描
单元测试 简单部署
部分环境部署 开发测试 推送到测试环境 团队间协作 编译
自动接口测试 无部署
mock服务器 接口测试 将接口模拟发布 交付测试 编译
自动验收测试 全环境部署 自动回归测试 推送到用户验证环境 交付运维 编译 容器部署
负载节点 升级脚本验证
release notes验收 推送到正式环境 正式上线 编译
构建容器 容器部署
负载节点 无测试 允许回滚 对上面的操作进行拆分后，可以分为对资源的管理工作：
二进制包
下载代码、依赖管理、编译、打包、代码扫描、单元测试 容器 构建、发布、拉取、运行 部署 架构即代码、蓝绿发布、回滚 设计原则 # 前一段时间写了一篇分层架构模式，这里以分层的方式去说明部署流水线的分层关系。这里的分层其实是理解或概念的层面。这里将分部署流水线设计分为几个层次：服务层，流程层，原子操作层。
服务层 提供自定义能力，可以将流程和原子操作组合成一个适用于当前业务系统的。这个是最顶层，最实用的实用层。
流程层 提供一整套流程提供各种各样的流程。大到可以将整体持续交付写到一个Pipeline内，也可以只对容器构建，发布过程形成一个Pipeline。只要之后可以用流程去组织各种各样的大的服务。</description></item><item><title>数据库版本管理</title><link>https://guowei1651.github.io/devops/02.undivided/06-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/</link><pubDate>Sat, 22 Apr 2023 12:52:56 +0800</pubDate><guid>https://guowei1651.github.io/devops/02.undivided/06-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/</guid><description>概述 # 数据库管理要求：
数据库升级 数据库备份 数据库容灾与恢复 数据库版本兼容 数据库升级不停机 数据迁移 技术方案设计 # 技术方案实施 # Sqoop</description></item><item><title>数据库备份设计</title><link>https://guowei1651.github.io/devops/02.undivided/07-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%87%E4%BB%BD%E8%AE%BE%E8%AE%A1/</link><pubDate>Sat, 22 Apr 2023 12:52:56 +0800</pubDate><guid>https://guowei1651.github.io/devops/02.undivided/07-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%87%E4%BB%BD%E8%AE%BE%E8%AE%A1/</guid><description>概述： # 在所有的软件系统中都有数据持久化的需求。而平常我们在软件系统中使用最多的方式就是数据库。所以，就需要对数据库的可靠性做一些必要的设计。以保证之后在项目上线运营过程中发生不可修复的问题，以此来整体提高软件系统的整体可靠性。
随着软件行业的不断发展，行业中也对软件各个层面上的解决方案都提供了高性能、靠可靠的解决方案。现在在数据存储层面也形成了很多解决方案。如：RDBMS的分库分片技术、NoSql的CAP解决方案、NewSQL技术、BigTable技术等。虽然数据存储层也有着层出不穷的存储技术，就像作者之前说的一样。每项技术都有它所擅长的方向，都有它的问题解决域。所以，不是每一项技术都可以应用到所有的场景下。
针对业务系统中的结构化数据存储领域，仍然是RDBMS占有着很大的优势。就算是RDBMS型的数据库也可以再划分为很多种类型。鉴于本文关系的是数据库的存储（物理）结构，从数据库的存储结构上将数据库分为：内存式、文件系统、物理机。基本上一个比较成熟的数据库都是支持这些模式。
内存式 文件系统 物理机 Oracle TimesTen 本身支持 本身支持 Postgresql 不支持，支持表空间 本身支持 不支持 Mysql MEMORY存储引擎 本身支持 InnoDB存储引擎 Sqlite3 本身支持 本身支持 不支持 数据库使用过程中需要发挥RDBMS的特点。在满足业务上的需求的同时，还需要满足技术上的、运维上的很多需求。所以接下来就从数据库设计开始一步一步的深入数据库可靠性设计的方方面面。
数据库驱动开发： # 现在业界有一种不成文的规定：在项目没有发展到一定阶段时，开发模型都会直接使用数据库驱动开发。然后在到达一定阶段之后，再进行重构。 这里对数据库驱动开发的软件过程或思维模式的指导下，简单的对项目的实施过程进行一下阐述：
根据业务分析出数据库逻辑结构； $\color{#FF00FF}{设计数据库的运维方法}$； 规划数据库容量，并发量 设计数据库物理存储结构 设计容灾与备份方案 等 开发、测试、部署之后即可交付。 数据库驱动开发模式是对软件无知状态下的一种探索。它忽略了前期、中期、后期的很多分析与度量的内容。并且省略了上面的第二条。而且根据作者在之后会介绍仓库系统及知识库架构模式中的指导：可以将数据库作为以一个知识库。也不会进行提前的风险评估。知识库是用来在不同的业务或者服务间共享知识与数据。所以，这里并不是推荐这种开发模式，并请尽量不要使用数据库驱动开发模式。
数据库设计： # 数据库设计一般可以分为：概念结构设计、逻辑结构设计、物理结构设计。概念结构设计是将业务转化为数据库中结构的一个过程。逻辑结构设计是根据概念结构设计中的E-R图，具体的将实体关系，数据格式定义出来。物理结构设计是确定逻辑层的数据存储在什么样的硬件上，怎样存储在硬件上。
我们这里更关心物理结构设计。第一步是需要知道业务中的非功能需求。非功能需求可以评估出数据库的容量，并发量，数据类型等等信息。然后根据这些信息在进行下一步的设计工作。设计工作中要考虑的内容有：
数据库的存储容量是否能够容纳，是否需要进行分库，分表操作。 是读频繁型，还是写频繁型，还是都频繁型？ 数据库对数据写入到查询出的时延要求？ 是否允许进行读写分离设计？ 数据库是否允许冷备，还是只可以进行热备或者变形方案？ 数据库可以接受的备份方式：全量备份，增量备份（日志备份，差异备份），不备份？ 数据库恢复时允许丢失的数据的要求？ 数据库运维监控、容量监控、负载监控、热数据加速、死锁检测。 数据库恢复设计。恢复时间要求？恢复到的环境的要求？ 在设计过程中还需要考虑数据库中存储的数据的价值以及对于维护数据库可用、可靠的投入之间的投入产出比。因为一个完备的数据库设计可能成本会非常高。而对于一个小型的网页应用来看，不必要做的很完善。
并且因为数据库的备份工作一般情况下还是需要人员参与的，所以也需要制定一套完善的数据库操作规范。以防止在人为参与的情况下造成数据的丢失与不一致。并且需要设计一套完整的自动化数据库运维过程。
备份设计： # 数据库的备份需要从下图中的几个方面进行考虑。但在每个产品/项目中数据库的使用设计都是不尽兴同的，所以，对数据库的备份方面的设计还是要与使用设计相结合。这里只介绍备份设计中需要考虑的内容。
下面逐层介绍需要注意的内容：
逻辑结构层： 逻辑结构中是否可以进行读写分离时的部分表的备份，即是否有外键关系，表中的数据是否可以进行单独的导入导出操作。 数据索引是否与具体的存储结构和索引方式有关。如果有关需要将这些元数据一并保存。 数据库中的存储过程，触发器是否与表空间、逻辑数据库有关。 数据备份时使用锁表，还是停机的方式进行备份？ 中间件 中间件中的分片策略是否与具体的数据库有关，是否可以在中间上替换数据库实例？ 向中间件中新添加数据库实例时，分片策略是否需要变更？ 内存 表数据怎样被加载到内存中？ 是否有内存表的创建？内存表是否需要进行备份? 计算 计算是在磁盘上的数据中进行的还是在内存上的数据中进行的？ 是否有预处理、预计算结果保存表，每次备份重新计算还是直接保存预计算结果？ 裸设备 裸设备上的数据是否有工具可以备份成文件形式？并有工具可以恢复回去 裸设备导出与导入的速度？ 自动化 尽量的减少人工操作的内容，减少因为人工带入的错误。 规范流程 数据迁移工具的使用规范 数据备份过程规范 数据备份存储规范 数据备份恢复规范 参照： # 关于开发方法可以参照：TDD，ATDD，BDD，DDD，MDSD。</description></item><item><title>数据库自动化运维</title><link>https://guowei1651.github.io/devops/02.undivided/08-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%87%AA%E5%8A%A8%E5%8C%96%E8%BF%90%E7%BB%B4/</link><pubDate>Sat, 22 Apr 2023 12:52:56 +0800</pubDate><guid>https://guowei1651.github.io/devops/02.undivided/08-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%87%AA%E5%8A%A8%E5%8C%96%E8%BF%90%E7%BB%B4/</guid><description>网易数据库运维自动化演进与 AIOps 探索 详解十三款运维监控工具 美团数据库运维自动化系统构建之路
京东数据库智能运维平台建设之路 京东数据库运维自动化体系建设之路
数据库运维工具化：一切从“简”，只为DBA更轻松 传统DBA将死？饿了么数据库自动化运维实践</description></item><item><title>网络穿透</title><link>https://guowei1651.github.io/devops/02.undivided/09-%E7%BD%91%E7%BB%9C%E7%A9%BF%E9%80%8F/</link><pubDate>Sat, 22 Apr 2023 12:52:56 +0800</pubDate><guid>https://guowei1651.github.io/devops/02.undivided/09-%E7%BD%91%E7%BB%9C%E7%A9%BF%E9%80%8F/</guid><description>https://snail007.github.io/goproxy/manual/zh/#/</description></item></channel></rss>